[{"path":"/AGENTS.html","id":null,"dir":"","previous_headings":"","what":"cuplyr Agent Notes","title":"cuplyr Agent Notes","text":"repo mixes R C++ (Rcpp) GPU-backed dplyr-like operations using libcudf. trickiest parts build tooling, GPU availability, keeping R-level schemas aligned GPU types.","code":""},{"path":[]},{"path":"/AGENTS.html","id":"fast-editrun-loop","dir":"","previous_headings":"Local Dev (pixi)","what":"Fast edit/run loop","title":"cuplyr Agent Notes","text":"pixi run configure (CUDA/cudf paths change). Edit code. pixi run install (full rebuild) pixi run load-dev (fast reload R). Spot-check R (e.g., gpu_details(), tbl_gpu(mtcars)).","code":""},{"path":"/AGENTS.html","id":"when-to-use-each-task","dir":"","previous_headings":"Local Dev (pixi)","what":"When to use each task","title":"cuplyr Agent Notes","text":"pixi run load-dev: tight inner loop R changes quick checks. pixi run install: C++ changes exports changed. pixi run dev: suspect stale artifacts (clean + rebuild). pixi run test: always run implementing feature (requires GPU).","code":""},{"path":"/AGENTS.html","id":"core-data-structures","dir":"","previous_headings":"","what":"Core Data Structures","title":"cuplyr Agent Notes","text":"tbl_gpu list ptr (externalptr), schema (names + types), groups, exec_mode (\"eager\"/\"lazy\"), lazy_ops (AST node NULL).","code":""},{"path":"/AGENTS.html","id":"type-mappings-r---gpu","dir":"","previous_headings":"","what":"Type Mappings (R -> GPU)","title":"cuplyr Agent Notes","text":"logical -> BOOL8 integer -> INT32 double -> FLOAT64 character -> STRING Date -> TIMESTAMP_DAYS POSIXct -> TIMESTAMP_MICROSECONDS factor -> INT32 (codes ) integer64 -> FLOAT64 (precision loss > 2^53, warn)","code":""},{"path":"/AGENTS.html","id":"current-c-layout-split-from-transfercpp","dir":"","previous_headings":"","what":"Current C++ Layout (split from transfer.cpp)","title":"cuplyr Agent Notes","text":"src/transfer_io.cpp: R <-> GPU conversion, collect/head/df_to_gpu. src/ops_filter.cpp: filter operations mask handling. src/ops_compare.cpp: comparison ops used summarise temp columns. src/ops_mutate.cpp: mutate copy/replace ops. src/ops_select.cpp: select operations. src/ops_groupby.cpp: summarise/groupby logic. src/gpu_info.cpp: device availability/info. src/cuda_utils.hpp: check_cuda() helper. src/ops_common.hpp: shared operator mapping helpers. src/gpu_table.hpp: pointer ownership helpers cudf::table.","code":""},{"path":"/AGENTS.html","id":"r-entry-points","dir":"","previous_headings":"","what":"R Entry Points","title":"cuplyr Agent Notes","text":"R/tbl-gpu.R: tbl_gpu() constructor + schema metadata. R/mutate.R, R/filter.R, R/select.R, R/arrange.R, R/summarise.R: dplyr verbs. R/collect.R: pulls data back R warns INT64 precision. R/gpu-memory.R: memory reporting GC helpers. R/utils.R: shared helpers (type mapping, wrap_gpu_call() clearer GPU errors).","code":""},{"path":"/AGENTS.html","id":"known-sharp-edges-things-that-were-hard","dir":"","previous_headings":"","what":"Known Sharp Edges (things that were hard)","title":"cuplyr Agent Notes","text":"cudf header names differ version. bitmask_allocation_size_bytes lives cudf/null_mask.hpp environment. Avoid cudf/bitmask.hpp. R type vs GPU type mismatch can silently break results. Keep gpu_type_from_r() df_to_gpu() sync (logical/Date/POSIXct especially). GPU detected common CI local dev. Tests use skip_if_no_gpu(); don’t remove . Rcpp exports need regeneration moving/adding functions: run Rcpp::compileAttributes() devtools::document(). INT64 precision: gpu_collect() returns doubles; warn values exceed 2^53. Memory growth: GPU op tends allocate new tables. Replacement mutate paths optimized, GC still matters. Join memory warnings: joins estimate output size warn close available GPU memory; actual allocation can still fail. String columns: Arrow-style storage (offsets + char data). slicing, offsets chars must kept Join ordering: cuDF join outputs unordered; stable-sort join maps left_map (right_map) src/ops_join.cpp match dplyr. Join unmatched rows: cuDF uses JoinNoMatch sentinel; gather treats negatives wraparound. Current fix sanitizes join maps CPU (replace nrows) gather uses out_of_bounds_policy::NULLIFY. cuDF gather API: environment’s cudf::gather signature negative_index_policy. Join headers: join APIs live cudf/join/join.hpp env (cudf/join.hpp).","code":""},{"path":"/AGENTS.html","id":"debugging-local-build-failures","dir":"","previous_headings":"","what":"Debugging Local Build Failures","title":"cuplyr Agent Notes","text":"cudf header can’t found, check pixi environment paths src/Makevars. Run pixi run configure updating CUDA/cudf libs. Use rg --files -g '*bitmask*' $CONDA_PREFIX/include/cudf locate moved headers. Join build errors: confirm #include <cudf/join/join.hpp> avoid device-side Thrust unless compiling nvcc.","code":""},{"path":"/AGENTS.html","id":"adding-new-gpu-ops-local-loop","dir":"","previous_headings":"","what":"Adding New GPU Ops (local loop)","title":"cuplyr Agent Notes","text":"Implement appropriate src/ops_*.cpp file. Add // [[Rcpp::export]] function. Run Rcpp::compileAttributes() regenerate R/RcppExports.R + src/RcppExports.cpp. Add R wrapper R/*.R tests tests/testthat/.","code":""},{"path":"/AGENTS.html","id":"when-you-touch-types-local-loop","dir":"","previous_headings":"","what":"When You Touch Types (local loop)","title":"cuplyr Agent Notes","text":"Update schema: R/utils.R (gpu_type_from_r). Update collect/head conversion new cudf types. Add tests round-trip behavior.","code":""},{"path":"/AGENTS.html","id":"joins-ast--optimizer-notes","dir":"","previous_headings":"","what":"Joins (AST + optimizer notes)","title":"cuplyr Agent Notes","text":"Lazy joins build ast_join two inputs; source pointers attached via set_ast_source_ptr() lowering. infer_schema.ast_join uses build_join_schema() R/join.R. Inner: left--> left, right--> right. Left: left-pushed. Right: right-pushed. Full: side-pushdown. Projection/dead-column pruning across joins uses build_join_output_info() map output columns back left/right sources. Right join implemented via swapped left join + column reorder; ensure desired column names exist gpu_select.","code":""},{"path":"/AGENTS.html","id":"code-review-quick-checklist-saves-time","dir":"","previous_headings":"","what":"Code Review Quick Checklist (saves time)","title":"cuplyr Agent Notes","text":"Type alignment: R/utils.R src/transfer_io.cpp must agree type mapping. Head/collect parity: type supported gpu_collect(), ensure gpu_head() uses conversion path. Arrange semantics: Confirm stable sort support libcudf, NA ordering, group-prepend behavior R/arrange.R. Rcpp exports: new C++ functions exist, verify R/RcppExports.R src/RcppExports.cpp updated. Tests: New verb features matching tests/testthat/test-*.R coverage use skip_if_no_gpu(). Joins: Verify left-table order, right-key dropping (keep = FALSE drops right keys even names differ), join pushdown rules.","code":""},{"path":"/AGENTS.html","id":"bugfix-workflow","dir":"","previous_headings":"","what":"Bugfix Workflow","title":"cuplyr Agent Notes","text":"Test-first (STRICT): bug reported, always add failing test reproduces implementing fix. test passes unexpectedly, revert fix, confirm failure, re-apply.","code":""},{"path":"/AGENTS.html","id":"recent-session-notes","dir":"","previous_headings":"","what":"Recent Session Notes","title":"cuplyr Agent Notes","text":"Exec mode field: tbl_gpu now includes exec_mode; tests/structure checks must allow (see helper updates). Exec mode propagation: constructors created verbs now explicitly carry forward .data$exec_mode (avoid option/env-driven mode drift). lazy_ops invariant: pending work NULL (list()). Legacy empty-list values normalized NULL new_tbl_gpu() compute(). lazy_ops validation: non-empty invalid lazy_ops objects now fail fast clear error compute/optimizer paths. Bind generic fallback: bind_rows.default / bind_cols.default now delegate dplyr non-tbl_gpu inputs; tbl_gpu methods remain GPU-backed. Lazy vs eager tests: Added cross-mode comparisons using tibble::as_tibble() avoid rownames/class mismatches. Filter parsing: Boolean literal fast-path avoids eval_tidy without data mask prevent name-collision bugs. Mutate parsing: Supports left-associative +/- chains (e.g., + b + c) lowering sequential ops. Optimizer barriers: Barrier reattachment uses helper avoid R copy--modify pitfalls. Benchmarking: benchmark/benchmark_memory.R compares lazy vs eager memory/time using synthetic taxi data. Filter pushdown benchmark: benchmark/benchmark_filter_pushdown.R compares auto vs manual filter placement reports GPU memory deltas. Join tests: tests/testthat/test-join.R includes eager/lazy joins, multi-key, renamed keys, edge-case comparisons vs base dplyr.","code":""},{"path":[]},{"path":"/CONTRIBUTING.html","id":"developer-setup","dir":"","previous_headings":"","what":"Developer Setup","title":"Contributing to cuplyr","text":"cuplyr uses pixi manage CUDA RAPIDS dependencies reproducibly.","code":""},{"path":"/CONTRIBUTING.html","id":"first-time-setup","dir":"","previous_headings":"Developer Setup","what":"First time setup","title":"Contributing to cuplyr","text":"","code":"# Install pixi (if not already installed) curl -fsSL https://pixi.sh/install.sh | bash  # Clone and build git clone https://github.com/bbtheo/cuplyr.git cd cuplyr pixi run install"},{"path":"/CONTRIBUTING.html","id":"daily-workflow","dir":"","previous_headings":"Developer Setup","what":"Daily workflow","title":"Contributing to cuplyr","text":"Option : pixi shell (recommended — run normal R commands) Option B: pixi run (shell activation)","code":"pixi shell          # Activates the environment R CMD INSTALL .     # Build after C++ changes R -e 'devtools::load_all()'  # Quick reload for R-only changes R -e 'devtools::test()'      # Run tests R                   # Interactive R session exit                # Leave pixi shell pixi run install    # Configure + build pixi run load-dev   # Quick reload (R only) pixi run test       # Run tests pixi run r          # Start R"},{"path":[]},{"path":[]},{"path":[]},{"path":"/CONTRIBUTING.html","id":"exports-and-namespace","dir":"","previous_headings":"Code Guidelines","what":"Exports and NAMESPACE","title":"Contributing to cuplyr","text":"Always use roxygen2 exports. Never edit NAMESPACE hand. run devtools::document() regenerate NAMESPACE.","code":"#' My new function #' #' @param x Input #' @return Output #' @export my_function <- function(x) { ... }"},{"path":"/CONTRIBUTING.html","id":"adding-a-new-dplyr-verb","dir":"","previous_headings":"Code Guidelines","what":"Adding a new dplyr verb","title":"Contributing to cuplyr","text":"See “Implementing New dplyr Verb” section .claude/CLAUDE.md full pattern (C++ implementation, R wrapper, NAMESPACE exports, tests).","code":""},{"path":"/CONTRIBUTING.html","id":"testing","dir":"","previous_headings":"Code Guidelines","what":"Testing","title":"Contributing to cuplyr","text":"tests use testthat (edition 3) GPU tests must start skip_if_no_gpu() Run tests: pixi run test Test helpers tests/testthat/helper-gpu.R","code":"test_that(\"my feature works\", {   skip_if_no_gpu()    df <- data.frame(x = 1:5)   result <- tbl_gpu(df) |> my_verb() |> collect()   expect_equal(result$x, expected) })"},{"path":"/CONTRIBUTING.html","id":"bug-fixes","dir":"","previous_headings":"Code Guidelines","what":"Bug fixes","title":"Contributing to cuplyr","text":"fixing bug, always write failing test first, implement fix.","code":""},{"path":"/CONTRIBUTING.html","id":"project-structure","dir":"","previous_headings":"","what":"Project Structure","title":"Contributing to cuplyr","text":"","code":"cuplyr/ ├── R/               # R code (dplyr verbs, AST, optimizer) ├── src/             # C++ code (Rcpp bindings to libcudf) ├── tests/testthat/  # Test suite ├── man/             # Generated docs (don't edit directly) ├── configure        # Build configuration script ├── pixi.toml        # Pixi dependency manager config └── DESCRIPTION      # R package metadata"},{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"Apache License","title":"Apache License","text":"Version 2.0, January 2004 <http://www.apache.org/licenses/>","code":""},{"path":[]},{"path":"/LICENSE.html","id":"id_1-definitions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"1. Definitions","title":"Apache License","text":"“License” shall mean terms conditions use, reproduction, distribution defined Sections 1 9 document. “Licensor” shall mean copyright owner entity authorized copyright owner granting License. “Legal Entity” shall mean union acting entity entities control, controlled , common control entity. purposes definition, “control” means () power, direct indirect, cause direction management entity, whether contract otherwise, (ii) ownership fifty percent (50%) outstanding shares, (iii) beneficial ownership entity. “” (“”) shall mean individual Legal Entity exercising permissions granted License. “Source” form shall mean preferred form making modifications, including limited software source code, documentation source, configuration files. “Object” form shall mean form resulting mechanical transformation translation Source form, including limited compiled object code, generated documentation, conversions media types. “Work” shall mean work authorship, whether Source Object form, made available License, indicated copyright notice included attached work (example provided Appendix ). “Derivative Works” shall mean work, whether Source Object form, based (derived ) Work editorial revisions, annotations, elaborations, modifications represent, whole, original work authorship. purposes License, Derivative Works shall include works remain separable , merely link (bind name) interfaces , Work Derivative Works thereof. “Contribution” shall mean work authorship, including original version Work modifications additions Work Derivative Works thereof, intentionally submitted Licensor inclusion Work copyright owner individual Legal Entity authorized submit behalf copyright owner. purposes definition, “submitted” means form electronic, verbal, written communication sent Licensor representatives, including limited communication electronic mailing lists, source code control systems, issue tracking systems managed , behalf , Licensor purpose discussing improving Work, excluding communication conspicuously marked otherwise designated writing copyright owner “Contribution.” “Contributor” shall mean Licensor individual Legal Entity behalf Contribution received Licensor subsequently incorporated within Work.","code":""},{"path":"/LICENSE.html","id":"id_2-grant-of-copyright-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"2. Grant of Copyright License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable copyright license reproduce, prepare Derivative Works , publicly display, publicly perform, sublicense, distribute Work Derivative Works Source Object form.","code":""},{"path":"/LICENSE.html","id":"id_3-grant-of-patent-license","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"3. Grant of Patent License","title":"Apache License","text":"Subject terms conditions License, Contributor hereby grants perpetual, worldwide, non-exclusive, -charge, royalty-free, irrevocable (except stated section) patent license make, made, use, offer sell, sell, import, otherwise transfer Work, license applies patent claims licensable Contributor necessarily infringed Contribution(s) alone combination Contribution(s) Work Contribution(s) submitted. institute patent litigation entity (including cross-claim counterclaim lawsuit) alleging Work Contribution incorporated within Work constitutes direct contributory patent infringement, patent licenses granted License Work shall terminate date litigation filed.","code":""},{"path":"/LICENSE.html","id":"id_4-redistribution","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"4. Redistribution","title":"Apache License","text":"may reproduce distribute copies Work Derivative Works thereof medium, without modifications, Source Object form, provided meet following conditions: () must give recipients Work Derivative Works copy License; (b) must cause modified files carry prominent notices stating changed files; (c) must retain, Source form Derivative Works distribute, copyright, patent, trademark, attribution notices Source form Work, excluding notices pertain part Derivative Works; (d) Work includes “NOTICE” text file part distribution, Derivative Works distribute must include readable copy attribution notices contained within NOTICE file, excluding notices pertain part Derivative Works, least one following places: within NOTICE text file distributed part Derivative Works; within Source form documentation, provided along Derivative Works; , within display generated Derivative Works, wherever third-party notices normally appear. contents NOTICE file informational purposes modify License. may add attribution notices within Derivative Works distribute, alongside addendum NOTICE text Work, provided additional attribution notices construed modifying License. may add copyright statement modifications may provide additional different license terms conditions use, reproduction, distribution modifications, Derivative Works whole, provided use, reproduction, distribution Work otherwise complies conditions stated License.","code":""},{"path":"/LICENSE.html","id":"id_5-submission-of-contributions","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"5. Submission of Contributions","title":"Apache License","text":"Unless explicitly state otherwise, Contribution intentionally submitted inclusion Work Licensor shall terms conditions License, without additional terms conditions. Notwithstanding , nothing herein shall supersede modify terms separate license agreement may executed Licensor regarding Contributions.","code":""},{"path":"/LICENSE.html","id":"id_6-trademarks","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"6. Trademarks","title":"Apache License","text":"License grant permission use trade names, trademarks, service marks, product names Licensor, except required reasonable customary use describing origin Work reproducing content NOTICE file.","code":""},{"path":"/LICENSE.html","id":"id_7-disclaimer-of-warranty","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"7. Disclaimer of Warranty","title":"Apache License","text":"Unless required applicable law agreed writing, Licensor provides Work (Contributor provides Contributions) “” BASIS, WITHOUT WARRANTIES CONDITIONS KIND, either express implied, including, without limitation, warranties conditions TITLE, NON-INFRINGEMENT, MERCHANTABILITY, FITNESS PARTICULAR PURPOSE. solely responsible determining appropriateness using redistributing Work assume risks associated exercise permissions License.","code":""},{"path":"/LICENSE.html","id":"id_8-limitation-of-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"8. Limitation of Liability","title":"Apache License","text":"event legal theory, whether tort (including negligence), contract, otherwise, unless required applicable law (deliberate grossly negligent acts) agreed writing, shall Contributor liable damages, including direct, indirect, special, incidental, consequential damages character arising result License use inability use Work (including limited damages loss goodwill, work stoppage, computer failure malfunction, commercial damages losses), even Contributor advised possibility damages.","code":""},{"path":"/LICENSE.html","id":"id_9-accepting-warranty-or-additional-liability","dir":"","previous_headings":"Terms and Conditions for use, reproduction, and distribution","what":"9. Accepting Warranty or Additional Liability","title":"Apache License","text":"redistributing Work Derivative Works thereof, may choose offer, charge fee , acceptance support, warranty, indemnity, liability obligations /rights consistent License. However, accepting obligations, may act behalf sole responsibility, behalf Contributor, agree indemnify, defend, hold Contributor harmless liability incurred , claims asserted , Contributor reason accepting warranty additional liability. END TERMS CONDITIONS","code":""},{"path":"/LICENSE.html","id":"appendix-how-to-apply-the-apache-license-to-your-work","dir":"","previous_headings":"","what":"APPENDIX: How to apply the Apache License to your work","title":"Apache License","text":"apply Apache License work, attach following boilerplate notice, fields enclosed brackets [] replaced identifying information. (Don’t include brackets!) text enclosed appropriate comment syntax file format. also recommend file class name description purpose included “printed page” copyright notice easier identification within third-party archives.","code":"Copyright [yyyy] [name of copyright owner]  Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at    http://www.apache.org/licenses/LICENSE-2.0  Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License."},{"path":"/articles/complex-analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Complex Data Analysis with cuplyr","text":"vignette demonstrates use cuplyr real-world data analysis workflows. ’ll cover multi-step analytical pipelines, branching analyses, working different data types, patterns handling large datasets efficiently.","code":"library(cuplyr) library(dplyr)"},{"path":"/articles/complex-analysis.html","id":"building-analytical-workflows","dir":"Articles","previous_headings":"","what":"Building Analytical Workflows","title":"Complex Data Analysis with cuplyr","text":"Real analysis rarely consists single operation. Let’s walk progressively complex workflows.","code":""},{"path":"/articles/complex-analysis.html","id":"example-dataset","dir":"Articles","previous_headings":"Building Analytical Workflows","what":"Example Dataset","title":"Complex Data Analysis with cuplyr","text":"’ll create synthetic sales dataset demonstrate patterns:","code":"set.seed(42) n <- 10000  sales_data <- data.frame(  transaction_id = seq_len(n),  date = as.Date(\"2023-01-01\") + sample(0:364, n, replace = TRUE),  customer_id = sample(1:500, n, replace = TRUE),  product_category = sample(c(\"Electronics\", \"Clothing\", \"Food\", \"Home\", \"Sports\"),                            n, replace = TRUE),  region = sample(c(\"North\", \"South\", \"East\", \"West\"), n, replace = TRUE),  quantity = sample(1:10, n, replace = TRUE),  unit_price = round(runif(n, 5, 500), 2),  discount_pct = sample(c(0, 5, 10, 15, 20), n, replace = TRUE,                        prob = c(0.5, 0.2, 0.15, 0.1, 0.05)) )  # Transfer to GPU gpu_sales <- tbl_gpu(sales_data, lazy = TRUE)"},{"path":"/articles/complex-analysis.html","id":"multi-step-revenue-analysis","dir":"Articles","previous_headings":"Building Analytical Workflows","what":"Multi-Step Revenue Analysis","title":"Complex Data Analysis with cuplyr","text":"Let’s compute revenue discounts applied, analyze multiple dimensions:","code":"revenue_analysis <- gpu_sales |>  # Step 1: Calculate derived metrics  mutate(    gross_amount = quantity * unit_price,    discount_amount = gross_amount * discount_pct / 100,    net_revenue = gross_amount - discount_amount  ) |>  # Step 2: Filter to significant transactions  filter(net_revenue > 50) |>  # Step 3: Aggregate by category and region  group_by(product_category, region) |>  summarise(    total_revenue = sum(net_revenue),    total_transactions = n(),    avg_transaction = mean(net_revenue),    total_quantity = sum(quantity)  ) |>  # Step 4: Sort by revenue  arrange(desc(total_revenue)) |>  collect()  head(revenue_analysis, 10)"},{"path":"/articles/complex-analysis.html","id":"calculating-metrics-across-groups","dir":"Articles","previous_headings":"Building Analytical Workflows","what":"Calculating Metrics Across Groups","title":"Complex Data Analysis with cuplyr","text":"Compute group-level statistics compare overall metrics:","code":"# Overall metrics overall_stats <- gpu_sales |>  mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>  summarise(    total_revenue = sum(revenue),    avg_revenue = mean(revenue),    total_orders = n()  ) |>  collect()  # Per-category metrics category_stats <- gpu_sales |>  mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>  group_by(product_category) |>  summarise(    category_revenue = sum(revenue),    category_avg = mean(revenue),    category_orders = n()  ) |>  arrange(desc(category_revenue)) |>  collect()  # Display results overall_stats category_stats"},{"path":"/articles/complex-analysis.html","id":"branching-analyses","dir":"Articles","previous_headings":"","what":"Branching Analyses","title":"Complex Data Analysis with cuplyr","text":"Often need run multiple analyses common base. Use compute() materialize intermediate results branch efficiently.","code":""},{"path":"/articles/complex-analysis.html","id":"creating-a-shared-base","dir":"Articles","previous_headings":"Branching Analyses","what":"Creating a Shared Base","title":"Complex Data Analysis with cuplyr","text":"","code":"# Prepare base data (filter and add computed columns) base_analysis <- gpu_sales |>  mutate(    revenue = quantity * unit_price * (1 - discount_pct/100),    is_high_value = unit_price > 200,    is_bulk = quantity >= 5  ) |>  filter(revenue > 0) |>  compute()  # Materialize on GPU  # Now branch into different analyses"},{"path":"/articles/complex-analysis.html","id":"branch-1-regional-performance","dir":"Articles","previous_headings":"Branching Analyses","what":"Branch 1: Regional Performance","title":"Complex Data Analysis with cuplyr","text":"","code":"regional_performance <- base_analysis |>  group_by(region) |>  summarise(    revenue = sum(revenue),    orders = n(),    high_value_orders = sum(is_high_value),    bulk_orders = sum(is_bulk)  ) |>  mutate(    high_value_pct = high_value_orders * 100 / orders,    bulk_pct = bulk_orders * 100 / orders  ) |>  arrange(desc(revenue)) |>  collect()  regional_performance"},{"path":"/articles/complex-analysis.html","id":"branch-2-category-deep-dive","dir":"Articles","previous_headings":"Branching Analyses","what":"Branch 2: Category Deep-Dive","title":"Complex Data Analysis with cuplyr","text":"","code":"category_analysis <- base_analysis |>  group_by(product_category) |>  summarise(    revenue = sum(revenue),    avg_price = mean(unit_price),    avg_quantity = mean(quantity),    orders = n()  ) |>  mutate(    revenue_per_order = revenue / orders  ) |>  arrange(desc(revenue_per_order)) |>  collect()  category_analysis"},{"path":"/articles/complex-analysis.html","id":"branch-3-discount-effectiveness","dir":"Articles","previous_headings":"Branching Analyses","what":"Branch 3: Discount Effectiveness","title":"Complex Data Analysis with cuplyr","text":"","code":"discount_analysis <- base_analysis |>  group_by(discount_pct) |>  summarise(    orders = n(),    total_revenue = sum(revenue),    avg_quantity = mean(quantity)  ) |>  mutate(    revenue_share = total_revenue * 100 / sum(total_revenue)  ) |>  arrange(discount_pct) |>  collect()  discount_analysis"},{"path":"/articles/complex-analysis.html","id":"working-with-dates","dir":"Articles","previous_headings":"","what":"Working with Dates","title":"Complex Data Analysis with cuplyr","text":"cuplyr supports Date POSIXct columns. ’s work temporal data.","code":""},{"path":"/articles/complex-analysis.html","id":"date-based-filtering","dir":"Articles","previous_headings":"Working with Dates","what":"Date-Based Filtering","title":"Complex Data Analysis with cuplyr","text":"","code":"# Filter to Q1 2023 q1_sales <- gpu_sales |>  filter(    date >= as.Date(\"2023-01-01\"),    date < as.Date(\"2023-04-01\")  ) |>  collect()  nrow(q1_sales)"},{"path":"/articles/complex-analysis.html","id":"extracting-date-components","dir":"Articles","previous_headings":"Working with Dates","what":"Extracting Date Components","title":"Complex Data Analysis with cuplyr","text":"date component extraction (year, month, day), compute R transferring use integer arithmetic:","code":"# Add date components in R, then transfer sales_with_dates <- sales_data |>  mutate(    month = as.integer(format(date, \"%m\")),    quarter = ceiling(month / 3),    day_of_week = as.integer(format(date, \"%u\"))  # 1=Monday, 7=Sunday  )  # Now analyze on GPU monthly_trend <- tbl_gpu(sales_with_dates, lazy = TRUE) |>  mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>  group_by(month) |>  summarise(    monthly_revenue = sum(revenue),    orders = n()  ) |>  arrange(month) |>  collect()  monthly_trend"},{"path":"/articles/complex-analysis.html","id":"quarterly-analysis","dir":"Articles","previous_headings":"Working with Dates","what":"Quarterly Analysis","title":"Complex Data Analysis with cuplyr","text":"","code":"quarterly_analysis <- tbl_gpu(sales_with_dates, lazy = TRUE) |>  mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>  group_by(quarter, region) |>  summarise(    revenue = sum(revenue),    orders = n()  ) |>  arrange(quarter, desc(revenue)) |>  collect()  quarterly_analysis"},{"path":[]},{"path":"/articles/complex-analysis.html","id":"customer-segmentation-by-purchase-behavior","dir":"Articles","previous_headings":"Segmentation Analysis","what":"Customer Segmentation by Purchase Behavior","title":"Complex Data Analysis with cuplyr","text":"","code":"customer_segments <- gpu_sales |>  mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>  group_by(customer_id) |>  summarise(    total_spent = sum(revenue),    order_count = n(),    avg_order_value = mean(revenue),    total_items = sum(quantity)  ) |>  collect()  # Segment in R (for complex logic) customer_segments <- customer_segments |>  mutate(    segment = case_when(      total_spent > 5000 & order_count > 20 ~ \"VIP\",      total_spent > 2000 | order_count > 10 ~ \"Regular\",      order_count > 5 ~ \"Occasional\",      TRUE ~ \"New\"    )  )  # Summary by segment table(customer_segments$segment)"},{"path":"/articles/complex-analysis.html","id":"product-performance-tiers","dir":"Articles","previous_headings":"Segmentation Analysis","what":"Product Performance Tiers","title":"Complex Data Analysis with cuplyr","text":"","code":"category_performance <- gpu_sales |>  mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>  group_by(product_category) |>  summarise(    revenue = sum(revenue),    units_sold = sum(quantity),    avg_price = mean(unit_price),    transactions = n()  ) |>  mutate(    revenue_per_unit = revenue / units_sold  ) |>  arrange(desc(revenue)) |>  collect()  category_performance"},{"path":[]},{"path":"/articles/complex-analysis.html","id":"beforeafter-comparison","dir":"Articles","previous_headings":"Comparative Analysis","what":"Before/After Comparison","title":"Complex Data Analysis with cuplyr","text":"Compare metrics across time periods:","code":"# Add period indicator in R sales_with_period <- sales_data |>  mutate(    period = ifelse(date < as.Date(\"2023-07-01\"), \"H1\", \"H2\")  )  period_comparison <- tbl_gpu(sales_with_period, lazy = TRUE) |>  mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>  group_by(period, product_category) |>  summarise(    revenue = sum(revenue),    orders = n(),    avg_order = mean(revenue)  ) |>  arrange(product_category, period) |>  collect()  period_comparison"},{"path":"/articles/complex-analysis.html","id":"region-to-region-comparison","dir":"Articles","previous_headings":"Comparative Analysis","what":"Region-to-Region Comparison","title":"Complex Data Analysis with cuplyr","text":"","code":"region_metrics <- gpu_sales |>  mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>  group_by(region) |>  summarise(    total_revenue = sum(revenue),    total_orders = n(),    avg_order_value = mean(revenue),    avg_quantity = mean(quantity),    avg_discount = mean(discount_pct)  ) |>  collect()  # Calculate indices relative to mean overall_avg <- mean(region_metrics$total_revenue) region_metrics$revenue_index <- region_metrics$total_revenue / overall_avg * 100  region_metrics"},{"path":[]},{"path":"/articles/complex-analysis.html","id":"memory-efficient-patterns","dir":"Articles","previous_headings":"Handling Large Datasets","what":"Memory-Efficient Patterns","title":"Complex Data Analysis with cuplyr","text":"working large data, minimize memory usage:","code":"# Pattern 1: Filter early, select only needed columns result <- tbl_gpu(huge_data, lazy = TRUE) |>  filter(status == \"active\") |>      # Reduce rows first  select(id, date, amount, category) |>  # Then reduce columns  mutate(amount_adj = amount * 1.1) |>  group_by(category) |>  summarise(total = sum(amount_adj)) |>  collect()  # Pattern 2: Process in logical segments base <- tbl_gpu(huge_data, lazy = TRUE) |>  filter(date >= start_date, date < end_date) |>  select(required_columns) |>  compute()  # Checkpoint: clear intermediate memory  result <- base |>  # Continue analysis on reduced data  group_by(segment) |>  summarise(metrics) |>  collect()"},{"path":"/articles/complex-analysis.html","id":"monitoring-memory-usage","dir":"Articles","previous_headings":"Handling Large Datasets","what":"Monitoring Memory Usage","title":"Complex Data Analysis with cuplyr","text":"","code":"# Check GPU memory state gpu_memory_state()  # After large operations, clean up gpu_gc()"},{"path":"/articles/complex-analysis.html","id":"multi-pass-analysis","dir":"Articles","previous_headings":"","what":"Multi-Pass Analysis","title":"Complex Data Analysis with cuplyr","text":"analyses require multiple passes data. Structure efficiently:","code":""},{"path":"/articles/complex-analysis.html","id":"pass-1-compute-aggregates","dir":"Articles","previous_headings":"Multi-Pass Analysis","what":"Pass 1: Compute Aggregates","title":"Complex Data Analysis with cuplyr","text":"","code":"# First pass: get category totals category_totals <- gpu_sales |>  mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>  group_by(product_category) |>  summarise(category_total = sum(revenue)) |>  collect()  category_totals"},{"path":"/articles/complex-analysis.html","id":"pass-2-detailed-analysis-with-context","dir":"Articles","previous_headings":"Multi-Pass Analysis","what":"Pass 2: Detailed Analysis with Context","title":"Complex Data Analysis with cuplyr","text":"","code":"# Add category totals back to data (in R) sales_enriched <- sales_data |>  left_join(category_totals, by = \"product_category\")  # Second pass: analyze with category context regional_share <- tbl_gpu(sales_enriched, lazy = TRUE) |>  mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>  group_by(product_category, region) |>  summarise(    region_revenue = sum(revenue),    category_total = max(category_total)  # Same value per group  ) |>  mutate(    region_share = region_revenue * 100 / category_total  ) |>  arrange(product_category, desc(region_share)) |>  collect()  regional_share"},{"path":"/articles/complex-analysis.html","id":"building-reusable-analysis-functions","dir":"Articles","previous_headings":"","what":"Building Reusable Analysis Functions","title":"Complex Data Analysis with cuplyr","text":"Encapsulate common patterns functions:","code":"#' Calculate revenue metrics by grouping columns #' #' @param gpu_data A tbl_gpu object with sales data #' @param ... Grouping columns #' @return Collected data frame with revenue metrics calculate_revenue_metrics <- function(gpu_data, ...) {  gpu_data |>    mutate(      gross = quantity * unit_price,      net = gross * (1 - discount_pct/100)    ) |>    group_by(...) |>    summarise(      gross_revenue = sum(gross),      net_revenue = sum(net),      total_discount = sum(gross) - sum(net),      order_count = n(),      avg_order = mean(net)    ) |>    mutate(      discount_rate = total_discount * 100 / gross_revenue    ) |>    arrange(desc(net_revenue)) |>    collect() }  # Use the function by_category <- calculate_revenue_metrics(gpu_sales, product_category) by_region <- calculate_revenue_metrics(gpu_sales, region) by_both <- calculate_revenue_metrics(gpu_sales, product_category, region)  head(by_both, 10)"},{"path":"/articles/complex-analysis.html","id":"parameterized-analysis","dir":"Articles","previous_headings":"Building Reusable Analysis Functions","what":"Parameterized Analysis","title":"Complex Data Analysis with cuplyr","text":"","code":"#' Analyze high-value transactions #' #' @param gpu_data A tbl_gpu object #' @param min_value Minimum transaction value #' @param group_col Column to group by analyze_high_value <- function(gpu_data, min_value = 100, group_col) {  group_col <- rlang::enquo(group_col)   gpu_data |>    mutate(transaction_value = quantity * unit_price * (1 - discount_pct/100)) |>    filter(transaction_value >= min_value) |>    group_by(!!group_col) |>    summarise(      high_value_revenue = sum(transaction_value),      high_value_count = n(),      avg_high_value = mean(transaction_value)    ) |>    arrange(desc(high_value_revenue)) |>    collect() }  # Different thresholds high_value_100 <- analyze_high_value(gpu_sales, 100, product_category) high_value_500 <- analyze_high_value(gpu_sales, 500, product_category)  high_value_100 high_value_500"},{"path":"/articles/complex-analysis.html","id":"combining-gpu-and-cpu-processing","dir":"Articles","previous_headings":"","what":"Combining GPU and CPU Processing","title":"Complex Data Analysis with cuplyr","text":"operations better suited R. Use hybrid approach:","code":""},{"path":"/articles/complex-analysis.html","id":"gpu-for-heavy-lifting","dir":"Articles","previous_headings":"Combining GPU and CPU Processing","what":"GPU for Heavy Lifting","title":"Complex Data Analysis with cuplyr","text":"","code":"# Heavy aggregation on GPU aggregated <- gpu_sales |>  mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>  group_by(product_category, region, discount_pct) |>  summarise(    revenue = sum(revenue),    orders = n(),    quantity = sum(quantity)  ) |>  collect()  nrow(aggregated)  # Much smaller than original"},{"path":"/articles/complex-analysis.html","id":"r-for-complex-logic","dir":"Articles","previous_headings":"Combining GPU and CPU Processing","what":"R for Complex Logic","title":"Complex Data Analysis with cuplyr","text":"","code":"# Complex categorization in R final_analysis <- aggregated |>  mutate(    performance = case_when(      revenue > quantile(revenue, 0.9) ~ \"Top 10%\",      revenue > quantile(revenue, 0.5) ~ \"Above Average\",      revenue > quantile(revenue, 0.25) ~ \"Below Average\",      TRUE ~ \"Bottom 25%\"    ),    discount_tier = case_when(      discount_pct == 0 ~ \"Full Price\",      discount_pct <= 10 ~ \"Light Discount\",      discount_pct <= 15 ~ \"Moderate Discount\",      TRUE ~ \"Heavy Discount\"    )  ) |>  group_by(performance, discount_tier) |>  summarise(    total_revenue = sum(revenue),    segments = n(),    .groups = \"drop\"  )  final_analysis"},{"path":"/articles/complex-analysis.html","id":"error-handling-in-analysis-pipelines","dir":"Articles","previous_headings":"","what":"Error Handling in Analysis Pipelines","title":"Complex Data Analysis with cuplyr","text":"Robust pipelines handle edge cases:","code":"safe_analysis <- function(data, min_rows = 100) {  # Validate input  if (!is.data.frame(data)) {    stop(\"Input must be a data frame\")  }   if (nrow(data) < min_rows) {    warning(\"Dataset has fewer than \", min_rows, \" rows\")  }   # Check required columns  required <- c(\"quantity\", \"unit_price\", \"discount_pct\")  missing <- setdiff(required, names(data))  if (length(missing) > 0) {    stop(\"Missing required columns: \", paste(missing, collapse = \", \"))  }   # Perform analysis  tryCatch({    tbl_gpu(data, lazy = TRUE) |>      mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>      filter(revenue > 0) |>      summarise(        total = sum(revenue),        avg = mean(revenue),        n = n()      ) |>      collect()  }, error = function(e) {    message(\"Analysis failed: \", e$message)    data.frame(total = NA, avg = NA, n = 0)  }) }  # Test with valid data safe_analysis(sales_data)"},{"path":"/articles/complex-analysis.html","id":"summary-statistics-dashboard","dir":"Articles","previous_headings":"","what":"Summary Statistics Dashboard","title":"Complex Data Analysis with cuplyr","text":"Create comprehensive summary:","code":"create_sales_dashboard <- function(gpu_data) {  # Overall metrics  overall <- gpu_data |>    mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>    summarise(      total_revenue = sum(revenue),      total_orders = n(),      total_units = sum(quantity),      avg_order_value = mean(revenue),      avg_discount = mean(discount_pct)    ) |>    collect()   # Top categories  top_categories <- gpu_data |>    mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>    group_by(product_category) |>    summarise(revenue = sum(revenue), orders = n()) |>    arrange(desc(revenue)) |>    collect()   # Regional breakdown  regional <- gpu_data |>    mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>    group_by(region) |>    summarise(revenue = sum(revenue), orders = n()) |>    arrange(desc(revenue)) |>    collect()   list(    overall = overall,    by_category = top_categories,    by_region = regional,    generated_at = Sys.time()  ) }  dashboard <- create_sales_dashboard(gpu_sales)  cat(\"=== Sales Dashboard ===\\n\\n\") cat(\"Overall Metrics:\\n\") print(dashboard$overall) cat(\"\\nBy Category:\\n\") print(dashboard$by_category) cat(\"\\nBy Region:\\n\") print(dashboard$by_region)"},{"path":"/articles/complex-analysis.html","id":"performance-comparison","dir":"Articles","previous_headings":"","what":"Performance Comparison","title":"Complex Data Analysis with cuplyr","text":"Compare GPU vs CPU performance data: small datasets like example, CPU may faster due transfer overhead. GPU advantage becomes clear millions rows.","code":"library(bench)  # Benchmark: GPU vs CPU for aggregation comparison <- bench::mark(  gpu = {    tbl_gpu(sales_data, lazy = TRUE) |>      mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>      group_by(product_category, region) |>      summarise(        total = sum(revenue),        avg = mean(revenue),        n = n()      ) |>      collect()  },  cpu = {    sales_data |>      mutate(revenue = quantity * unit_price * (1 - discount_pct/100)) |>      group_by(product_category, region) |>      summarise(        total = sum(revenue),        avg = mean(revenue),        n = n(),        .groups = \"drop\"      )  },  check = FALSE,  min_iterations = 5 )  comparison"},{"path":"/articles/complex-analysis.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Complex Data Analysis with cuplyr","text":"vignette(\"getting-started\") - Basic cuplyr usage vignette(\"query-optimization\") - Understanding optimizer Package documentation specific functions","code":""},{"path":"/articles/complex-analysis.html","id":"best-practices-summary","dir":"Articles","previous_headings":"","what":"Best Practices Summary","title":"Complex Data Analysis with cuplyr","text":"Filter select early reduce data size Use lazy mode complex multi-step pipelines Use compute() checkpoint branching Prepare date components R transfer Use hybrid GPU/CPU - GPU aggregation, R complex logic Monitor memory gpu_memory_state() gpu_gc() Encapsulate patterns reusable functions Handle errors gracefully production pipelines","code":""},{"path":"/articles/getting-started.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting Started with cuplyr","text":"cuplyr dplyr backend executes data manipulation operations NVIDIA GPUs using RAPIDS cuDF library. know dplyr, already know cuplyr - verbs work syntax, just faster large datasets.","code":"library(cuplyr) library(dplyr)"},{"path":"/articles/getting-started.html","id":"when-to-use-gpu-acceleration","dir":"Articles","previous_headings":"","what":"When to Use GPU Acceleration","title":"Getting Started with cuplyr","text":"GPU acceleration shines : data millions rows (typically >10M clear benefits) Operations computationally intensive (aggregations, sorting, filtering) ’re exploratory analysis repeated queries small datasets (<100K rows), overhead transferring data GPU often outweighs speedup. Stick regular dplyr cases.","code":""},{"path":"/articles/getting-started.html","id":"basic-workflow","dir":"Articles","previous_headings":"","what":"Basic Workflow","title":"Getting Started with cuplyr","text":"typical cuplyr workflow three steps: Transfer data GPU tbl_gpu() Process dplyr verbs (filter, mutate, summarise, etc.) Bring results back collect()","code":""},{"path":"/articles/getting-started.html","id":"creating-a-gpu-table","dir":"Articles","previous_headings":"Basic Workflow","what":"Creating a GPU Table","title":"Getting Started with cuplyr","text":"data now GPU memory. original R data frame unchanged.","code":"# Transfer a data frame to GPU memory gpu_cars <- tbl_gpu(mtcars)  # Check that it's on the GPU gpu_cars"},{"path":"/articles/getting-started.html","id":"using-dplyr-verbs","dir":"Articles","previous_headings":"Basic Workflow","what":"Using dplyr Verbs","title":"Getting Started with cuplyr","text":"Use familiar dplyr verbs exactly normally:","code":"# Filter rows efficient_cars <- gpu_cars |>   filter(mpg > 25)  # Add computed columns with_kpl <- gpu_cars |>   mutate(kpl = mpg * 0.425144)  # Select specific columns subset <- gpu_cars |>   select(mpg, cyl, hp)  # Sort rows sorted <- gpu_cars |>   arrange(desc(mpg))  # Group and summarize by_cyl <- gpu_cars |>   group_by(cyl) |>   summarise(     avg_mpg = mean(mpg),     avg_hp = mean(hp),     count = n()   )"},{"path":"/articles/getting-started.html","id":"collecting-results","dir":"Articles","previous_headings":"Basic Workflow","what":"Collecting Results","title":"Getting Started with cuplyr","text":"Operations build GPU. Use collect() bring results back R:","code":"# Bring the grouped summary back to R result <- by_cyl |>   collect()  result"},{"path":"/articles/getting-started.html","id":"a-complete-example","dir":"Articles","previous_headings":"","what":"A Complete Example","title":"Getting Started with cuplyr","text":"’s realistic workflow analyzing mtcars dataset:","code":"analysis <- tbl_gpu(mtcars) |>   # Keep only cars with reasonable fuel economy    filter(mpg > 15) |>   # Calculate power-to-weight ratio   mutate(     power_to_weight = hp / wt,     is_efficient = mpg > 20   ) |>   # Group by number of cylinders   group_by(cyl) |>   # Calculate summary statistics   summarise(     n_cars = n(),     avg_mpg = mean(mpg),     avg_power_ratio = mean(power_to_weight),     best_mpg = max(mpg)   ) |>   # Sort by average MPG descending   arrange(desc(avg_mpg)) |>   # Bring back to R   collect()  analysis"},{"path":"/articles/getting-started.html","id":"chaining-multiple-operations","dir":"Articles","previous_headings":"","what":"Chaining Multiple Operations","title":"Getting Started with cuplyr","text":"can chain many operations needed. cuplyr handles execution efficiently:","code":"# Complex pipeline result <- tbl_gpu(mtcars) |>   filter(cyl %in% c(4, 6)) |>   mutate(     efficiency_score = mpg / hp * 100,     weight_class = wt * 1000   ) |>   filter(efficiency_score > 5) |>   select(mpg, cyl, hp, efficiency_score, weight_class) |>   arrange(desc(efficiency_score)) |>   collect()  head(result)"},{"path":[]},{"path":"/articles/getting-started.html","id":"filter","dir":"Articles","previous_headings":"Supported Operations","what":"filter()","title":"Getting Started with cuplyr","text":"Filter rows based conditions:","code":"# Comparison operators filter(x > 10) filter(x >= 10) filter(x < 10) filter(x <= 10) filter(x == 10) filter(x != 10)  # Multiple conditions (combined with AND) filter(x > 10, y < 5)  # Column-to-column comparisons filter(col_a > col_b)"},{"path":"/articles/getting-started.html","id":"select","dir":"Articles","previous_headings":"Supported Operations","what":"select()","title":"Getting Started with cuplyr","text":"Select reorder columns:","code":"# By name select(mpg, cyl, hp)  # Exclude columns select(-disp, -drat)  # Rename while selecting select(fuel_economy = mpg, cylinders = cyl)  # Helper functions select(starts_with(\"d\")) select(ends_with(\"t\")) select(contains(\"p\"))"},{"path":"/articles/getting-started.html","id":"mutate","dir":"Articles","previous_headings":"Supported Operations","what":"mutate()","title":"Getting Started with cuplyr","text":"Create modify columns:","code":"# Arithmetic operations mutate(kpl = mpg * 0.425) mutate(power_ratio = hp / wt) mutate(hp_squared = hp ^ 2)  # Multiple columns at once mutate(   a = x + y,   b = x - y,   c = a * 2  # Can reference newly created columns )  # Replace existing columns mutate(mpg = mpg * 0.425)  # Converts to km/L in place"},{"path":"/articles/getting-started.html","id":"arrange","dir":"Articles","previous_headings":"Supported Operations","what":"arrange()","title":"Getting Started with cuplyr","text":"Sort rows:","code":"# Ascending (default) arrange(mpg)  # Descending arrange(desc(mpg))  # Multiple columns arrange(cyl, desc(mpg))"},{"path":"/articles/getting-started.html","id":"group_by-summarise","dir":"Articles","previous_headings":"Supported Operations","what":"group_by() + summarise()","title":"Getting Started with cuplyr","text":"Grouped aggregations:","code":"# Available aggregation functions group_by(cyl) |>   summarise(     total = sum(mpg),     average = mean(mpg),     minimum = min(mpg),     maximum = max(mpg),     count = n(),     std_dev = sd(mpg),     variance = var(mpg)   )  # Multiple grouping columns group_by(cyl, gear) |>   summarise(avg_mpg = mean(mpg))"},{"path":"/articles/getting-started.html","id":"supported-column-types","dir":"Articles","previous_headings":"","what":"Supported Column Types","title":"Getting Started with cuplyr","text":"cuplyr handles R types:","code":""},{"path":"/articles/getting-started.html","id":"execution-modes-eager-vs-lazy","dir":"Articles","previous_headings":"","what":"Execution Modes: Eager vs Lazy","title":"Getting Started with cuplyr","text":"cuplyr supports two execution modes:","code":""},{"path":"/articles/getting-started.html","id":"eager-mode-default","dir":"Articles","previous_headings":"Execution Modes: Eager vs Lazy","what":"Eager Mode (Default)","title":"Getting Started with cuplyr","text":"Operations execute immediately. Simple predictable:","code":"# Default: eager execution eager_tbl <- tbl_gpu(mtcars) is_lazy(eager_tbl)  # FALSE  # Each operation runs immediately result <- eager_tbl |>   filter(mpg > 20) |>   # Executes now    mutate(x = hp * 2) |> # Executes now   collect()"},{"path":"/articles/getting-started.html","id":"lazy-mode","dir":"Articles","previous_headings":"Execution Modes: Eager vs Lazy","what":"Lazy Mode","title":"Getting Started with cuplyr","text":"Operations deferred optimized execution: Lazy mode enables query optimization like filter pushdown operation fusion. See vignette(\"query-optimization\") details.","code":"# Enable lazy execution lazy_tbl <- tbl_gpu(mtcars, lazy = TRUE) is_lazy(lazy_tbl)  # TRUE  # Operations build an AST without executing pipeline <- lazy_tbl |>   filter(mpg > 20) |>   mutate(x = hp * 2) |>   filter(cyl == 4)  # Check pending operations has_pending_ops(pipeline)  # TRUE  # Execute everything at once (optimized) result <- pipeline |> collect()"},{"path":[]},{"path":"/articles/getting-started.html","id":"compute","dir":"Articles","previous_headings":"Controlling Execution","what":"compute()","title":"Getting Started with cuplyr","text":"Execute pending operations keep data GPU:","code":"# Useful when branching into multiple analyses base_data <- tbl_gpu(mtcars, lazy = TRUE) |>   filter(mpg > 15) |>   mutate(power_ratio = hp / wt) |>   compute()  # Execute and materialize on GPU  # Now branch without re-running the filter/mutate analysis_a <- base_data |> filter(cyl == 4) |> collect() analysis_b <- base_data |> filter(cyl == 6) |> collect()"},{"path":"/articles/getting-started.html","id":"show_query","dir":"Articles","previous_headings":"Controlling Execution","what":"show_query()","title":"Getting Started with cuplyr","text":"Inspect pending operations lazy mode:","code":"lazy_pipeline <- tbl_gpu(mtcars, lazy = TRUE) |>   filter(mpg > 20) |>   mutate(x = hp * 2)  show_query(lazy_pipeline)"},{"path":"/articles/getting-started.html","id":"memory-management","dir":"Articles","previous_headings":"","what":"Memory Management","title":"Getting Started with cuplyr","text":"GPU memory managed automatically R’s garbage collector. tbl_gpu object longer referenced, GPU memory freed. Check GPU memory usage: Force garbage collection needed:","code":"# Current memory state gpu_memory_state() # Clean up unreferenced GPU objects gpu_gc()"},{"path":"/articles/getting-started.html","id":"best-practices","dir":"Articles","previous_headings":"","what":"Best Practices","title":"Getting Started with cuplyr","text":"Filter early - Reduce data size expensive operations Select needed columns - Less data process Use lazy mode complex pipelines - Enables optimization Keep data GPU - Avoid repeated transfers compute() Collect late - transfer final results R","code":"# Good: filter and select early result <- tbl_gpu(mtcars, lazy = TRUE) |>   filter(mpg > 20) |>                    # Reduce rows first   select(mpg, cyl, hp, wt) |>            # Reduce columns   mutate(power_ratio = hp / wt) |>       # Now compute   group_by(cyl) |>   summarise(avg_ratio = mean(power_ratio)) |>   collect()                               # Transfer only final result"},{"path":"/articles/getting-started.html","id":"error-handling","dir":"Articles","previous_headings":"","what":"Error Handling","title":"Getting Started with cuplyr","text":"cuplyr validates operations provides informative errors:","code":"# Referencing non-existent column try({   tbl_gpu(mtcars) |>     filter(nonexistent_column > 5) })  # Type mismatches are caught try({   tbl_gpu(mtcars) |>     filter(mpg > \"not a number\") })"},{"path":"/articles/getting-started.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Getting Started with cuplyr","text":"vignette(\"query-optimization\") - Deep dive AST optimizer vignette(\"performance-tips\") - Maximizing GPU performance Package documentation: ?tbl_gpu, ?compute, ?gpu_memory_state","code":""},{"path":"/articles/getting-started.html","id":"system-requirements","dir":"Articles","previous_headings":"","what":"System Requirements","title":"Getting Started with cuplyr","text":"NVIDIA GPU CUDA support (Compute Capability >= 7.0) CUDA Toolkit >= 12.2 RAPIDS cuDF >= 25.12 R >= 4.3.0","code":""},{"path":"/articles/query-optimization.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Query Optimization in cuplyr","text":"use cuplyr lazy mode, operations aren’t executed immediately. Instead, build Abstract Syntax Tree (AST) represents query. execution, AST passes optimizer rewrites query better performance. vignette explains: AST represents operations six optimization passes applied queries filter pushdown works detail optimization matters","code":"library(cuplyr) library(dplyr)"},{"path":"/articles/query-optimization.html","id":"the-abstract-syntax-tree-ast","dir":"Articles","previous_headings":"","what":"The Abstract Syntax Tree (AST)","title":"Query Optimization in cuplyr","text":"write dplyr pipeline lazy mode, operation creates node AST. tree grows bottom (source data) top (final operation).","code":"# Create a lazy pipeline pipeline <- tbl_gpu(mtcars, lazy = TRUE) |>   filter(mpg > 20) |>   mutate(power_ratio = hp / wt) |>   select(mpg, cyl, power_ratio) |>   arrange(desc(mpg))  # View the AST show_query(pipeline)"},{"path":"/articles/query-optimization.html","id":"ast-node-types","dir":"Articles","previous_headings":"The Abstract Syntax Tree (AST)","what":"AST Node Types","title":"Query Optimization in cuplyr","text":"dplyr verb creates specific node type:","code":""},{"path":"/articles/query-optimization.html","id":"how-the-ast-grows","dir":"Articles","previous_headings":"The Abstract Syntax Tree (AST)","what":"How the AST Grows","title":"Query Optimization in cuplyr","text":"operation wraps previous one: source node bottom. Operations stack top. executed, tree traversed bottom top.","code":"# This pipeline: tbl_gpu(mtcars, lazy = TRUE) |>   filter(mpg > 20) |>   mutate(x = hp * 2)  # Creates this AST structure: # mutate[x] #   filter[1 predicates] #     source[11 cols]"},{"path":"/articles/query-optimization.html","id":"the-optimization-pipeline","dir":"Articles","previous_headings":"","what":"The Optimization Pipeline","title":"Query Optimization in cuplyr","text":"execution, AST passes six optimization passes order: Projection Pruning - Remove unused columns early Mutate Fusion - Combine consecutive mutates Dead Column Pruning - Remove unused computed columns Filter Pushdown - Move filters closer source Filter Reordering - Cheapest filters first Filter Fusion - Combine simple filters one kernel","code":""},{"path":"/articles/query-optimization.html","id":"why-order-matters","dir":"Articles","previous_headings":"The Optimization Pipeline","what":"Why Order Matters","title":"Query Optimization in cuplyr","text":"passes carefully ordered: Projection pruning runs first reduce data width Mutate fusion happens filter pushdown create larger blocks Dead column pruning cleans projection changes Filter passes run last since earlier passes may create new opportunities","code":""},{"path":"/articles/query-optimization.html","id":"pass-1-projection-pruning","dir":"Articles","previous_headings":"","what":"Pass 1: Projection Pruning","title":"Query Optimization in cuplyr","text":"pass pushes column selections tree reduce data width early.","code":""},{"path":"/articles/query-optimization.html","id":"before-optimization","dir":"Articles","previous_headings":"Pass 1: Projection Pruning","what":"Before Optimization","title":"Query Optimization in cuplyr","text":"","code":"# User writes: tbl_gpu(mtcars, lazy = TRUE) |>   mutate(power_ratio = hp / wt) |>   select(mpg, power_ratio) |>   collect()  # Unoptimized AST processes all 11 columns through mutate"},{"path":"/articles/query-optimization.html","id":"after-optimization","dir":"Articles","previous_headings":"Pass 1: Projection Pruning","what":"After Optimization","title":"Query Optimization in cuplyr","text":"optimizer inserts select node mutate fetch columns needed (mpg, hp, wt):","code":"# Optimized execution order: # 1. Select only mpg, hp, wt from source # 2. Compute power_ratio = hp / wt # 3. Select mpg, power_ratio for output  # Benefit: 11 columns -> 3 columns early"},{"path":"/articles/query-optimization.html","id":"impact","dir":"Articles","previous_headings":"Pass 1: Projection Pruning","what":"Impact","title":"Query Optimization in cuplyr","text":"wide tables, projection pruning dramatically reduces memory bandwidth. Instead copying columns every operation, needed columns flow pipeline.","code":""},{"path":"/articles/query-optimization.html","id":"pass-2-mutate-fusion","dir":"Articles","previous_headings":"","what":"Pass 2: Mutate Fusion","title":"Query Optimization in cuplyr","text":"Consecutive mutate() calls combined safe.","code":""},{"path":"/articles/query-optimization.html","id":"before-optimization-1","dir":"Articles","previous_headings":"Pass 2: Mutate Fusion","what":"Before Optimization","title":"Query Optimization in cuplyr","text":"","code":"# User writes (or code generates): tbl_gpu(mtcars, lazy = TRUE) |>   mutate(a = hp + 10) |>   mutate(b = wt * 2) |>   mutate(c = a + b) |>   collect()  # Three separate mutate nodes = three intermediate tables"},{"path":"/articles/query-optimization.html","id":"after-optimization-1","dir":"Articles","previous_headings":"Pass 2: Mutate Fusion","what":"After Optimization","title":"Query Optimization in cuplyr","text":"","code":"# Fused into single mutate: # mutate(a = hp + 10, b = wt * 2, c = a + b)  # One intermediate table instead of three"},{"path":"/articles/query-optimization.html","id":"fusion-guards","dir":"Articles","previous_headings":"Pass 2: Mutate Fusion","what":"Fusion Guards","title":"Query Optimization in cuplyr","text":"Fusion blocked : Combined expressions exceed 8 (memory bandwidth tradeoff) Circular dependencies exist many intermediate columns reused (>4 intermediates >3 uses )","code":""},{"path":"/articles/query-optimization.html","id":"dependency-handling","dir":"Articles","previous_headings":"Pass 2: Mutate Fusion","what":"Dependency Handling","title":"Query Optimization in cuplyr","text":"fusing creates dependencies, expressions topologically sorted:","code":"# Input expressions: #   c = a + b #   a = hp + 10 #   b = wt * 2  # After topological sort: #   a = hp + 10    (no deps) #   b = wt * 2     (no deps) #   c = a + b      (depends on a, b)"},{"path":"/articles/query-optimization.html","id":"pass-3-dead-column-pruning","dir":"Articles","previous_headings":"","what":"Pass 3: Dead Column Pruning","title":"Query Optimization in cuplyr","text":"projection pushdown mutate fusion, computed columns may longer used. pass removes .","code":""},{"path":"/articles/query-optimization.html","id":"example","dir":"Articles","previous_headings":"Pass 3: Dead Column Pruning","what":"Example","title":"Query Optimization in cuplyr","text":"pass walks backward AST, tracking columns actually required downstream operations.","code":"# User writes: tbl_gpu(mtcars, lazy = TRUE) |>   mutate(     a = hp + 10,     b = wt * 2,     c = mpg * 2   ) |>   select(mpg, a) |>  # Only using 'a', not 'b' or 'c'   collect()  # After dead column pruning: # mutate(a = hp + 10) only - 'b' and 'c' are never computed"},{"path":"/articles/query-optimization.html","id":"pass-4-filter-pushdown","dir":"Articles","previous_headings":"","what":"Pass 4: Filter Pushdown","title":"Query Optimization in cuplyr","text":"Filter pushdown one impactful optimizations. moves filter() operations closer data source, reducing number rows processed subsequent operations.","code":""},{"path":"/articles/query-optimization.html","id":"the-core-principle","dir":"Articles","previous_headings":"Pass 4: Filter Pushdown","what":"The Core Principle","title":"Query Optimization in cuplyr","text":"Fewer rows = faster everything. filtering early: Less data flows mutate computations Less data sort arrange Less memory bandwidth consumed","code":""},{"path":"/articles/query-optimization.html","id":"when-pushdown-happens","dir":"Articles","previous_headings":"Pass 4: Filter Pushdown","what":"When Pushdown Happens","title":"Query Optimization in cuplyr","text":"filter can pushed mutate filter’s predicate columns produced mutate.","code":""},{"path":"/articles/query-optimization.html","id":"can-push","dir":"Articles","previous_headings":"Pass 4: Filter Pushdown > When Pushdown Happens","what":"Can Push","title":"Query Optimization in cuplyr","text":"","code":"# This filter can be pushed down: pipeline <- tbl_gpu(mtcars, lazy = TRUE) |>   mutate(power_ratio = hp / wt) |>   filter(mpg > 20) |>  # mpg exists before mutate   collect()  # Optimized order: # 1. filter(mpg > 20) - removes rows first # 2. mutate(power_ratio) - computed on fewer rows"},{"path":"/articles/query-optimization.html","id":"cannot-push","dir":"Articles","previous_headings":"Pass 4: Filter Pushdown > When Pushdown Happens","what":"Cannot Push","title":"Query Optimization in cuplyr","text":"","code":"# This filter cannot be pushed: pipeline <- tbl_gpu(mtcars, lazy = TRUE) |>   mutate(power_ratio = hp / wt) |>   filter(power_ratio > 50) |>  # power_ratio created by mutate   collect()  # Must stay in order: # 1. mutate(power_ratio) - creates the column # 2. filter(power_ratio > 50) - uses it"},{"path":"/articles/query-optimization.html","id":"pushdown-across-select","dir":"Articles","previous_headings":"Pass 4: Filter Pushdown","what":"Pushdown Across Select","title":"Query Optimization in cuplyr","text":"Filters can also push select() select keeps predicate columns:","code":"# Original: tbl_gpu(data, lazy = TRUE) |>   select(a, b, c) |>   filter(a > 10)  # If select keeps 'a', filter pushes below: # filter(a > 10) # select(a, b, c)"},{"path":"/articles/query-optimization.html","id":"the-algorithm","dir":"Articles","previous_headings":"Pass 4: Filter Pushdown","what":"The Algorithm","title":"Query Optimization in cuplyr","text":"filter pushdown algorithm: Recursively process AST root leaves Extract columns used predicates Check input mutate node mutate’s output columns don’t overlap predicate columns, swap Repeat pushdowns possible","code":"# Implementation sketch (from optimizer.R): push_down_filters <- function(ast) {   # Get columns used in filter predicates   filter_cols <- get_predicate_columns(ast$predicates)    if (ast$input$type == \"mutate\") {     mutate_outputs <- get_output_columns(ast$input$expressions)      # Can push if no overlap     if (length(intersect(filter_cols, mutate_outputs)) == 0) {       # Swap: filter goes below mutate       new_filter <- ast_filter(ast$input$input, ast$predicates)       ast$input$input <- new_filter       return(ast$input)  # mutate is now on top     }   }    ast }"},{"path":"/articles/query-optimization.html","id":"real-world-impact","dir":"Articles","previous_headings":"Pass 4: Filter Pushdown","what":"Real-World Impact","title":"Query Optimization in cuplyr","text":"Consider 100-million row dataset filter(x > threshold) keeps 10% rows: Wait - total? quite. critical difference memory: Without pushdown: mutate allocates 100M-row output, filter pushdown: filter first (minimal allocation), mutate allocates 10M-row output memory savings compound pipeline. multiple mutates filters, pushdown can reduce peak memory 10x .","code":""},{"path":"/articles/query-optimization.html","id":"pass-5-filter-reordering","dir":"Articles","previous_headings":"","what":"Pass 5: Filter Reordering","title":"Query Optimization in cuplyr","text":"multiple filter predicates exist, ’re reordered estimated cost.","code":""},{"path":[]},{"path":"/articles/query-optimization.html","id":"example-1","dir":"Articles","previous_headings":"Pass 5: Filter Reordering","what":"Example","title":"Query Optimization in cuplyr","text":"running cheaper filters first, rows eliminated expensive comparisons.","code":"# User writes: filter(expensive_col > other_col, cheap_col > 10)  # Reordered to: filter(cheap_col > 10, expensive_col > other_col)"},{"path":"/articles/query-optimization.html","id":"safety-check","dir":"Articles","previous_headings":"Pass 5: Filter Reordering","what":"Safety Check","title":"Query Optimization in cuplyr","text":"Non-deterministic predicates reordered preserve correctness.","code":""},{"path":"/articles/query-optimization.html","id":"pass-6-filter-fusion","dir":"Articles","previous_headings":"","what":"Pass 6: Filter Fusion","title":"Query Optimization in cuplyr","text":"Simple scalar predicates can fused single GPU kernel call.","code":""},{"path":"/articles/query-optimization.html","id":"before-fusion","dir":"Articles","previous_headings":"Pass 6: Filter Fusion","what":"Before Fusion","title":"Query Optimization in cuplyr","text":"","code":"# Multiple filter conditions: filter(a > 10, b < 20, c == 5)  # Without fusion: three separate filter kernel calls"},{"path":"/articles/query-optimization.html","id":"after-fusion","dir":"Articles","previous_headings":"Pass 6: Filter Fusion","what":"After Fusion","title":"Query Optimization in cuplyr","text":"","code":"# Fused: single kernel with AND-mask  # One kernel computes: # mask = (a > 10) & (b < 20) & (c == 5) # apply_boolean_mask(data, mask)"},{"path":"/articles/query-optimization.html","id":"fusion-criteria","dir":"Articles","previous_headings":"Pass 6: Filter Fusion","what":"Fusion Criteria","title":"Query Optimization in cuplyr","text":"Filters fused conditions met: predicates simple scalar comparisons (column--column) Operators basic comparisons: ==, !=, >, >=, <, <= 4 predicates (GPU register limits) Column--column comparisons complex expressions remain separate.","code":""},{"path":"/articles/query-optimization.html","id":"optimization-barriers","dir":"Articles","previous_headings":"","what":"Optimization Barriers","title":"Query Optimization in cuplyr","text":"operations act barriers prevent optimization across : arrange() - Sort order must respected head() - Row limit must apply specific point summarise() - Aggregation changes row count collapse() - Explicit user barrier","code":""},{"path":"/articles/query-optimization.html","id":"why-barriers-exist","dir":"Articles","previous_headings":"Optimization Barriers","what":"Why Barriers Exist","title":"Query Optimization in cuplyr","text":"Consider: Pushing filter past arrange change rows remain.","code":"tbl_gpu(data, lazy = TRUE) |>   arrange(x) |>           # Barrier: establishes order   mutate(rank = row_number()) |>  # Depends on order   filter(rank <= 10)      # Cannot push past arrange!"},{"path":"/articles/query-optimization.html","id":"segment-optimization","dir":"Articles","previous_headings":"Optimization Barriers","what":"Segment Optimization","title":"Query Optimization in cuplyr","text":"optimizer handles barriers : Splitting AST barrier points Optimizing segment independently Reconnecting optimized segments","code":"# Pipeline with barrier: tbl_gpu(data, lazy = TRUE) |>   filter(a > 10) |>   mutate(b = a + 1) |>   arrange(b) |>           # Barrier here   filter(c > 5) |>   mutate(d = c + 1)  # Optimized as two segments: # Segment 1: source -> filter(a>10) -> mutate(b) # Segment 2: arrange(b) -> filter(c>5) -> mutate(d)"},{"path":[]},{"path":"/articles/query-optimization.html","id":"show_query","dir":"Articles","previous_headings":"Inspecting Optimization","what":"show_query()","title":"Query Optimization in cuplyr","text":"View pending AST optimization:","code":"pipeline <- tbl_gpu(mtcars, lazy = TRUE) |>   mutate(a = hp + 10) |>   filter(mpg > 20) |>   mutate(b = a + wt)  show_query(pipeline)"},{"path":"/articles/query-optimization.html","id":"understanding-the-output","dir":"Articles","previous_headings":"Inspecting Optimization","what":"Understanding the Output","title":"Query Optimization in cuplyr","text":"show_query() output shows: Node type key metadata Tree structure via indentation AST depth (number levels) Node count (total operations)","code":""},{"path":[]},{"path":"/articles/query-optimization.html","id":"example-1-filter-pushdown-in-action","dir":"Articles","previous_headings":"Practical Examples","what":"Example 1: Filter Pushdown in Action","title":"Query Optimization in cuplyr","text":"","code":"# Without lazy mode: operations execute in written order eager_result <- tbl_gpu(mtcars) |>   mutate(     a = hp + 10,     b = wt * 2,     c = mpg * 3   ) |>   filter(cyl == 4) |>  # Filters after computing all mutates   collect()  # With lazy mode: filter pushes down lazy_result <- tbl_gpu(mtcars, lazy = TRUE) |>   mutate(     a = hp + 10,     b = wt * 2,     c = mpg * 3   ) |>   filter(cyl == 4) |>  # Optimizer moves this before mutate   collect()  # Same result, but lazy version filters first identical(eager_result, lazy_result)"},{"path":"/articles/query-optimization.html","id":"example-2-complex-pipeline-optimization","dir":"Articles","previous_headings":"Practical Examples","what":"Example 2: Complex Pipeline Optimization","title":"Query Optimization in cuplyr","text":"example, optimizer: Pushes filter(cyl %% c(4,6), mpg > 18) first mutate Reorders filter predicates (scalar comparisons first) Fuses two filter predicates one kernel Prunes computed columns used downstream","code":"# A realistic analytics query result <- tbl_gpu(mtcars, lazy = TRUE) |>   # Step 1: Feature engineering   mutate(     power_to_weight = hp / wt,     fuel_efficiency = mpg / cyl,     is_powerful = hp > 150   ) |>   # Step 2: Filter to interesting subset   filter(     cyl %in% c(4, 6),     # Can push down (cyl exists)     mpg > 18              # Can push down (mpg exists)   ) |>   # Step 3: More features using filtered data   mutate(     efficiency_score = fuel_efficiency * power_to_weight   ) |>   # Step 4: Aggregate   group_by(cyl) |>   summarise(     avg_score = mean(efficiency_score),     count = n()   ) |>   # Step 5: Final ordering   arrange(desc(avg_score)) |>   collect()  result"},{"path":"/articles/query-optimization.html","id":"example-3-when-pushdown-doesnt-help","dir":"Articles","previous_headings":"Practical Examples","what":"Example 3: When Pushdown Doesn’t Help","title":"Query Optimization in cuplyr","text":"","code":"# Filter depends on computed column - cannot push result <- tbl_gpu(mtcars, lazy = TRUE) |>   mutate(power_ratio = hp / wt) |>   filter(power_ratio > 50) |>  # Must stay after mutate   collect()  # This is fine - the optimizer recognizes the dependency nrow(result)"},{"path":[]},{"path":"/articles/query-optimization.html","id":"use-lazy-mode-for-complex-pipelines","dir":"Articles","previous_headings":"Performance Tips","what":"1. Use Lazy Mode for Complex Pipelines","title":"Query Optimization in cuplyr","text":"","code":"# Enable lazy mode for optimization benefits tbl_gpu(data, lazy = TRUE) |>   # ... complex pipeline ...   collect()"},{"path":"/articles/query-optimization.html","id":"filter-on-source-columns-when-possible","dir":"Articles","previous_headings":"Performance Tips","what":"2. Filter on Source Columns When Possible","title":"Query Optimization in cuplyr","text":"","code":"# Good: filter uses source columns tbl_gpu(data, lazy = TRUE) |>   filter(status == \"active\", date > cutoff) |>  # Can push down   mutate(computed = complex_calculation(a, b))  # Less optimal: filter uses computed column tbl_gpu(data, lazy = TRUE) |>   mutate(computed = complex_calculation(a, b)) |>   filter(computed > threshold)  # Cannot push down"},{"path":"/articles/query-optimization.html","id":"let-the-optimizer-reorder","dir":"Articles","previous_headings":"Performance Tips","what":"3. Let the Optimizer Reorder","title":"Query Optimization in cuplyr","text":"Write filters logical order. optimizer reorder cost:","code":"# Write for readability filter(   department == \"Engineering\",   # May be expensive   is_active == TRUE,             # Cheap   salary > 50000                 # Cheap )  # Optimizer reorders to: is_active, salary, department"},{"path":"/articles/query-optimization.html","id":"use-collapse-for-control","dir":"Articles","previous_headings":"Performance Tips","what":"4. Use collapse() for Control","title":"Query Optimization in cuplyr","text":"need prevent optimization across boundary:","code":"tbl_gpu(data, lazy = TRUE) |>   filter(x > 10) |>   mutate(y = f(x)) |>   collapse() |>            # Barrier: optimize above and below separately   filter(z > 5) |>   collect()"},{"path":"/articles/query-optimization.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Query Optimization in cuplyr","text":"cuplyr’s query optimizer automatically improves pipelines : Projection pruning: process needed columns Mutate fusion: Reduce intermediate allocations Dead column pruning: Skip unnecessary computations Filter pushdown: Process fewer rows earlier Filter reordering: Cheap filters first Filter fusion: Combine filters single kernels workloads, simply use lazy mode write natural dplyr code. optimizer handles rest.","code":"# Just write natural dplyr: result <- tbl_gpu(big_data, lazy = TRUE) |>   mutate(derived = complex_expr) |>   filter(source_col > threshold) |>  # Automatically pushed down   group_by(category) |>   summarise(total = sum(derived)) |>   collect()"},{"path":"/articles/query-optimization.html","id":"further-reading","dir":"Articles","previous_headings":"","what":"Further Reading","title":"Query Optimization in cuplyr","text":"vignette(\"getting-started\") - Basic cuplyr usage ?optimize_ast - Internal optimizer documentation RAPIDS cuDF documentation GPU-specific optimizations","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Theo Blauberg. Author, maintainer. RAPIDS Team. Copyright holder.           libcudf library","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Blauberg T (2026). cuplyr: GPU-Accelerated Data Manipulation Dplyr Syntax. R package version 0.1.1.9000, https://github.com/bbtheo/cuplyr.","code":"@Manual{,   title = {cuplyr: GPU-Accelerated Data Manipulation with Dplyr Syntax},   author = {Theo Blauberg},   year = {2026},   note = {R package version 0.1.1.9000},   url = {https://github.com/bbtheo/cuplyr}, }"},{"path":[]},{"path":"/index.html","id":"dplyr-backend-for-gpu-acceleration-via-rapids-cudf","dir":"","previous_headings":"","what":"dplyr backend for GPU acceleration via RAPIDS cuDF","title":"GPU-Accelerated Data Manipulation with Dplyr Syntax","text":"cuplyr implements dplyr backend powered RAPIDS cuDF, NVIDIA’s GPU DataFrame library. Write standard dplyr code, execute GPU hardware.","code":"library(cuplyr)  tbl_gpu(sales_data, lazy = TRUE) |>   filter(year >= 2020, amount > 0) |>   mutate(revenue = amount * price) |>   group_by(region, quarter) |>   summarise(total = sum(revenue)) |>   inner_join(regions, by = \"region\") |>   arrange(desc(total)) |>   collect()"},{"path":"/index.html","id":"about","dir":"","previous_headings":"","what":"About","title":"GPU-Accelerated Data Manipulation with Dplyr Syntax","text":"cuplyr translates dplyr operations cuDF execution NVIDIA GPUs. follows backend pattern dbplyr: write standard R code, execute GPU hardware. approach can provide significant speedups larger datasets (typically >1M rows) without requiring major code changes. Built RAPIDS cuDF: cuDF open-source GPU DataFrame library developed NVIDIA’s RAPIDS team. provides optimized CUDA kernels data manipulation operations, backed Apache Arrow’s columnar memory format. cuplyr provides R interface execution engine.","code":""},{"path":"/index.html","id":"status","dir":"","previous_headings":"","what":"Status","title":"GPU-Accelerated Data Manipulation with Dplyr Syntax","text":"v0.1.0 experimental software active development. Breaking changes expected.","code":""},{"path":"/index.html","id":"supported-operations","dir":"","previous_headings":"Status","what":"Supported operations","title":"GPU-Accelerated Data Manipulation with Dplyr Syntax","text":"Data manipulation - filter() – row filtering comparison logical operators - select() – column selection reordering - mutate() – column transformations arithmetic - arrange() – row sorting desc() support, NA handling follows dplyr conventions - group_by() + summarise() – grouped aggregations (sum, mean, min, max, n) - left_join(), right_join(), inner_join(), full_join() – GPU joins key columns - collect() – transfer results back R - compute() – execute lazy operations, keep GPU - tbl_gpu(..., lazy = TRUE) – enable lazy evaluation AST optimization","code":""},{"path":"/index.html","id":"lazy-evaluation","dir":"","previous_headings":"Status","what":"Lazy evaluation","title":"GPU-Accelerated Data Manipulation with Dplyr Syntax","text":"Lazy mode defers execution collect() compute(), enabling automatic optimizations: - Projection pruning (drop unused columns early) - Filter pushdown (move filters closer data sources) - Mutate fusion (combine consecutive transformations)","code":"# Enable globally options(cuplyr.exec_mode = \"lazy\")  # Or per-table tbl_gpu(data, lazy = TRUE)"},{"path":[]},{"path":"/index.html","id":"not-yet-implemented","dir":"","previous_headings":"Status","what":"Not yet implemented","title":"GPU-Accelerated Data Manipulation with Dplyr Syntax","text":"Complex joins join_by() Window functions String operations Multi-GPU support Contributions feedback welcome.","code":""},{"path":"/index.html","id":"architecture","dir":"","previous_headings":"","what":"Architecture","title":"GPU-Accelerated Data Manipulation with Dplyr Syntax","text":"R layer: S3 methods implementing dplyr generics AST optimizer: Projection pruning, filter pushdown, operation fusion Native bindings: Rcpp interface libcudf C++ API Execution: cuDF GPU kernels via libcudf Memory: GPU-resident data automatic cleanup via R garbage collection","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":"/index.html","id":"try-on-google-colab","dir":"","previous_headings":"Installation","what":"Try on Google Colab","title":"GPU-Accelerated Data Manipulation with Dplyr Syntax","text":"fastest way try cuplyr — local setup required:","code":""},{"path":"/index.html","id":"quick-install","dir":"","previous_headings":"Installation","what":"Quick install","title":"GPU-Accelerated Data Manipulation with Dplyr Syntax","text":"Option : One-liner (auto-detects pixi, conda, system CUDA) Option B: R (CUDA + cuDF system) Option C: Using pixi (reproducible, manages CUDA/RAPIDS deps)","code":"git clone https://github.com/bbtheo/cuplyr.git && cd cuplyr && ./install.sh # Install R dependencies first install.packages(c(\"Rcpp\", \"dplyr\", \"rlang\", \"vctrs\", \"pillar\", \"glue\", \"cli\", \"tidyselect\", \"tibble\"))  # Then from the cuplyr directory: cuplyr::install_cuplyr(method = \"system\") # Install pixi: curl -fsSL https://pixi.sh/install.sh | bash git clone https://github.com/bbtheo/cuplyr.git cd cuplyr pixi run install"},{"path":"/index.html","id":"verify-installation","dir":"","previous_headings":"Installation","what":"Verify installation","title":"GPU-Accelerated Data Manipulation with Dplyr Syntax","text":"","code":"library(cuplyr) verify_installation() # Or check dependencies first: check_deps()"},{"path":"/index.html","id":"troubleshooting","dir":"","previous_headings":"Installation","what":"Troubleshooting","title":"GPU-Accelerated Data Manipulation with Dplyr Syntax","text":"","code":"# Full diagnostics for bug reports diagnostics()"},{"path":"/index.html","id":"developer-setup","dir":"","previous_headings":"Installation","what":"Developer setup","title":"GPU-Accelerated Data Manipulation with Dplyr Syntax","text":"See CONTRIBUTING.md contributor workflow using pixi shell. GitHub Actions trigger/run instructions docs/github-actions-runbook.md.","code":""},{"path":"/index.html","id":"performance","dir":"","previous_headings":"","what":"Performance","title":"GPU-Accelerated Data Manipulation with Dplyr Syntax","text":"Benchmark code lives benchmark/benchmark.R. Benchmarks 25 million rows (synthetic taxi data, median 10 iterations): Complete workflow: filter + mutate + group_by + summarise Hardware: Intel Core i9-12900K (16 cores), NVIDIA RTX 5070 (12 GB VRAM)","code":""},{"path":"/index.html","id":"acknowledgments","dir":"","previous_headings":"","what":"Acknowledgments","title":"GPU-Accelerated Data Manipulation with Dplyr Syntax","text":"project built RAPIDS cuDF NVIDIA RAPIDS AI team. License: Apache 2.0 Maintainer: @bbtheo Documentation: DEVELOPER_GUIDE.md","code":""},{"path":"/reference/add_id_column.html","id":null,"dir":"Reference","previous_headings":"","what":"Add .id column to identify source tables — add_id_column","title":"Add .id column to identify source tables — add_id_column","text":"Add .id column identify source tables","code":""},{"path":"/reference/add_id_column.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add .id column to identify source tables — add_id_column","text":"","code":"add_id_column(result, id_col_name, original_tables, source_names)"},{"path":"/reference/add_id_column.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add .id column to identify source tables — add_id_column","text":"result combined tbl_gpu id_col_name Name .id column original_tables List original tables (row counts) source_names Names/identifiers source","code":""},{"path":"/reference/add_id_column.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add .id column to identify source tables — add_id_column","text":"tbl_gpu .id column prepended","code":""},{"path":"/reference/add_null_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Add null columns to a table — add_null_columns","title":"Add null columns to a table — add_null_columns","text":"Add null columns table","code":""},{"path":"/reference/add_null_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add null columns to a table — add_null_columns","text":"","code":"add_null_columns(tbl, col_names, col_types)"},{"path":"/reference/add_null_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add null columns to a table — add_null_columns","text":"tbl tbl_gpu object col_names Names columns add col_types Types columns add","code":""},{"path":"/reference/add_null_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add null columns to a table — add_null_columns","text":"tbl_gpu additional null columns","code":""},{"path":"/reference/align_to_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Align a table to a target schema — align_to_schema","title":"Align a table to a target schema — align_to_schema","text":"Align table target schema","code":""},{"path":"/reference/align_to_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Align a table to a target schema — align_to_schema","text":"","code":"align_to_schema(tbl, target_schema)"},{"path":"/reference/align_to_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Align a table to a target schema — align_to_schema","text":"tbl tbl_gpu object target_schema List names types","code":""},{"path":"/reference/align_to_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Align a table to a target schema — align_to_schema","text":"tbl_gpu aligned target schema","code":""},{"path":"/reference/arrange.tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Arrange rows of a GPU table by column values — arrange.tbl_gpu","title":"Arrange rows of a GPU table by column values — arrange.tbl_gpu","text":"Orders rows GPU table values specified columns, similar dplyr::arrange(). Sorting performed entirely GPU using memory-efficient two-phase algorithm.","code":""},{"path":"/reference/arrange.tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arrange rows of a GPU table by column values — arrange.tbl_gpu","text":"","code":"# S3 method for class 'tbl_gpu' arrange(.data, ..., .by_group = FALSE)"},{"path":"/reference/arrange.tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arrange rows of a GPU table by column values — arrange.tbl_gpu","text":".data tbl_gpu object created tbl_gpu(). ... Column names expressions sort . Use desc(column) -column descending order. Multiple columns sorted order precedence (first column primary sort key). .by_group TRUE .data grouped, sort within groups prepending group columns sort specification. Default FALSE.","code":""},{"path":"/reference/arrange.tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arrange rows of a GPU table by column values — arrange.tbl_gpu","text":"tbl_gpu object rows reordered. GPU memory sorted result newly allocated (approximately 2x table size peak memory).","code":""},{"path":[]},{"path":"/reference/arrange.tbl_gpu.html","id":"sort-order","dir":"Reference","previous_headings":"","what":"Sort order","title":"Arrange rows of a GPU table by column values — arrange.tbl_gpu","text":"Default ascending order Use desc(column) -column descending order Multiple columns: first column primary key, second tiebreaker, etc. Sorting stable: ties preserve original relative order","code":""},{"path":"/reference/arrange.tbl_gpu.html","id":"na-handling","dir":"Reference","previous_headings":"","what":"NA handling","title":"Arrange rows of a GPU table by column values — arrange.tbl_gpu","text":"NA values placed last ascending order NA values placed first descending order","code":""},{"path":"/reference/arrange.tbl_gpu.html","id":"memory-usage","dir":"Reference","previous_headings":"","what":"Memory usage","title":"Arrange rows of a GPU table by column values — arrange.tbl_gpu","text":"arrange operation requires approximately 2x table size GPU memory: Original table Sort indices (4 bytes per row) New sorted table large tables, consider filtering reduce size sorting.","code":""},{"path":"/reference/arrange.tbl_gpu.html","id":"supported-column-types","dir":"Reference","previous_headings":"","what":"Supported column types","title":"Arrange rows of a GPU table by column values — arrange.tbl_gpu","text":"column types supported tbl_gpu can sorted: numeric, integer, character, logical, Date, POSIXct. Note: Character sorting uses binary/UTF-8 ordering, locale-aware collation.","code":""},{"path":[]},{"path":"/reference/arrange.tbl_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arrange rows of a GPU table by column values — arrange.tbl_gpu","text":"","code":"if (has_gpu()) {   gpu_mtcars <- tbl_gpu(mtcars)    # Sort by single column (ascending)   sorted <- gpu_mtcars |>     arrange(mpg) |>     collect()    # Sort descending   sorted_desc <- gpu_mtcars |>     arrange(desc(mpg)) |>     collect()    # Multiple columns: primary and secondary sort keys   sorted_multi <- gpu_mtcars |>     arrange(cyl, desc(mpg)) |>     collect()    # With grouped data   grouped_sort <- gpu_mtcars |>     group_by(cyl) |>     arrange(mpg, .by_group = TRUE) |>     collect() } #> Error in collect(arrange(gpu_mtcars, mpg)): could not find function \"collect\""},{"path":"/reference/as_eager.html","id":null,"dir":"Reference","previous_headings":"","what":"Switch to eager execution mode — as_eager","title":"Switch to eager execution mode — as_eager","text":"Computes pending operations returns tbl_gpu execute subsequent operations immediately.","code":""},{"path":"/reference/as_eager.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Switch to eager execution mode — as_eager","text":"","code":"as_eager(.data)"},{"path":"/reference/as_eager.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Switch to eager execution mode — as_eager","text":".data tbl_gpu object.","code":""},{"path":"/reference/as_eager.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Switch to eager execution mode — as_eager","text":"tbl_gpu eager execution mode.","code":""},{"path":"/reference/as_eager.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Switch to eager execution mode — as_eager","text":"","code":"if (has_gpu()) {   # Start lazy, switch to eager mid-pipeline   result <- tbl_gpu(mtcars, lazy = TRUE) |>     filter(mpg > 20) |>     as_eager() |>     mutate(x = hp * 2) |>  # executes immediately     collect() } #> Error in collect(mutate(as_eager(filter(tbl_gpu(mtcars, lazy = TRUE),     mpg > 20)), x = hp * 2)): could not find function \"collect\""},{"path":"/reference/as_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Switch to lazy execution mode — as_lazy","title":"Switch to lazy execution mode — as_lazy","text":"Returns tbl_gpu defer operations collect() compute() called.","code":""},{"path":"/reference/as_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Switch to lazy execution mode — as_lazy","text":"","code":"as_lazy(.data)"},{"path":"/reference/as_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Switch to lazy execution mode — as_lazy","text":".data tbl_gpu object.","code":""},{"path":"/reference/as_lazy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Switch to lazy execution mode — as_lazy","text":"tbl_gpu lazy execution mode.","code":""},{"path":"/reference/as_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Switch to lazy execution mode — as_lazy","text":"","code":"if (has_gpu()) {   # Create in eager mode, switch to lazy   gpu_data <- tbl_gpu(mtcars) |>     as_lazy() |>     filter(mpg > 20) |>     mutate(kpl = mpg * 0.425)  # not yet executed    # Execute with collect   result <- gpu_data |> collect() } #> Error in mutate(filter(as_lazy(tbl_gpu(mtcars)), mpg > 20), kpl = mpg *     0.425): could not find function \"mutate\""},{"path":"/reference/as_tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce to a GPU table — as_tbl_gpu","title":"Coerce to a GPU table — as_tbl_gpu","text":"Converts data frame compatible object tbl_gpu object, transferring data GPU memory.","code":""},{"path":"/reference/as_tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce to a GPU table — as_tbl_gpu","text":"","code":"as_tbl_gpu(x, ...)"},{"path":"/reference/as_tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce to a GPU table — as_tbl_gpu","text":"x data frame object coercible data frame. ... Additional arguments passed tbl_gpu().","code":""},{"path":"/reference/as_tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce to a GPU table — as_tbl_gpu","text":"tbl_gpu object data stored GPU.","code":""},{"path":[]},{"path":"/reference/as_tbl_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce to a GPU table — as_tbl_gpu","text":"","code":"if (has_gpu()) {   gpu_df <- as_tbl_gpu(iris)   print(gpu_df) } #> Rows: 150 #> Columns: 5 #> $ Sepal.Length <dbl> 5.1, 4.9, 4.7, 4.6, 5, 5.4, 4.6, 5, 4.4, 4.9 #> $ Sepal.Width  <dbl> 3.5, 3, 3.2, 3.1, 3.6, 3.9, 3.4, 3.4, 2.9, 3.1 #> $ Petal.Length <dbl> 1.4, 1.4, 1.3, 1.5, 1.4, 1.7, 1.4, 1.5, 1.4, 1.5 #> $ Petal.Width  <dbl> 0.2, 0.2, 0.2, 0.2, 0.2, 0.4, 0.3, 0.2, 0.2, 0.1 #> $ Species      <int> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1"},{"path":"/reference/ast_arrange.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an arrange AST node — ast_arrange","title":"Create an arrange AST node — ast_arrange","text":"Create arrange AST node","code":""},{"path":"/reference/ast_arrange.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an arrange AST node — ast_arrange","text":"","code":"ast_arrange(input, sort_specs, groups = character())"},{"path":"/reference/ast_arrange.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an arrange AST node — ast_arrange","text":"input Input AST node sort_specs List sort specifications (col_name, descending) groups Character vector group columns (.by_group)","code":""},{"path":"/reference/ast_arrange.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an arrange AST node — ast_arrange","text":"ast_arrange node","code":""},{"path":"/reference/ast_barrier.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a barrier AST node (optimization fence) — ast_barrier","title":"Create a barrier AST node (optimization fence) — ast_barrier","text":"Create barrier AST node (optimization fence)","code":""},{"path":"/reference/ast_barrier.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a barrier AST node (optimization fence) — ast_barrier","text":"","code":"ast_barrier(input)"},{"path":"/reference/ast_barrier.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a barrier AST node (optimization fence) — ast_barrier","text":"input Input AST node","code":""},{"path":"/reference/ast_barrier.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a barrier AST node (optimization fence) — ast_barrier","text":"ast_barrier node","code":""},{"path":"/reference/ast_count.html","id":null,"dir":"Reference","previous_headings":"","what":"Count nodes in an AST tree — ast_count","title":"Count nodes in an AST tree — ast_count","text":"Count nodes AST tree","code":""},{"path":"/reference/ast_count.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Count nodes in an AST tree — ast_count","text":"","code":"ast_count(node)"},{"path":"/reference/ast_count.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Count nodes in an AST tree — ast_count","text":"node Root AST node","code":""},{"path":"/reference/ast_count.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Count nodes in an AST tree — ast_count","text":"Integer count","code":""},{"path":"/reference/ast_depth.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the depth of an AST tree — ast_depth","title":"Get the depth of an AST tree — ast_depth","text":"Get depth AST tree","code":""},{"path":"/reference/ast_depth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the depth of an AST tree — ast_depth","text":"","code":"ast_depth(node)"},{"path":"/reference/ast_depth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the depth of an AST tree — ast_depth","text":"node Root AST node","code":""},{"path":"/reference/ast_depth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the depth of an AST tree — ast_depth","text":"Integer depth","code":""},{"path":"/reference/ast_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a filter AST node — ast_filter","title":"Create a filter AST node — ast_filter","text":"Create filter AST node","code":""},{"path":"/reference/ast_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a filter AST node — ast_filter","text":"","code":"ast_filter(input, predicates)"},{"path":"/reference/ast_filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a filter AST node — ast_filter","text":"input Input AST node predicates List predicate structures","code":""},{"path":"/reference/ast_filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a filter AST node — ast_filter","text":"ast_filter node","code":""},{"path":"/reference/ast_group_by.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a group_by AST node (metadata only) — ast_group_by","title":"Create a group_by AST node (metadata only) — ast_group_by","text":"Create group_by AST node (metadata )","code":""},{"path":"/reference/ast_group_by.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a group_by AST node (metadata only) — ast_group_by","text":"","code":"ast_group_by(input, groups)"},{"path":"/reference/ast_group_by.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a group_by AST node (metadata only) — ast_group_by","text":"input Input AST node groups Character vector grouping columns","code":""},{"path":"/reference/ast_group_by.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a group_by AST node (metadata only) — ast_group_by","text":"ast_group_by node","code":""},{"path":"/reference/ast_head.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a head/limit AST node — ast_head","title":"Create a head/limit AST node — ast_head","text":"Create head/limit AST node","code":""},{"path":"/reference/ast_head.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a head/limit AST node — ast_head","text":"","code":"ast_head(input, n)"},{"path":"/reference/ast_head.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a head/limit AST node — ast_head","text":"input Input AST node n Number rows keep","code":""},{"path":"/reference/ast_head.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a head/limit AST node — ast_head","text":"ast_head node","code":""},{"path":"/reference/ast_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a join AST node — ast_join","title":"Create a join AST node — ast_join","text":"Create join AST node","code":""},{"path":"/reference/ast_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a join AST node — ast_join","text":"","code":"ast_join(   type,   left,   right,   by,   keep = FALSE,   suffix = c(\".x\", \".y\"),   na_matches = \"na\" )"},{"path":"/reference/ast_join.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a join AST node — ast_join","text":"type Join type: \"inner\", \"left\", \"right\", \"full\" left Left input AST node right Right input AST node Join specification list(left = , right = ) keep Logical, keep key columns names match suffix Character vector length 2 na_matches Character, \"na\" \"never\"","code":""},{"path":"/reference/ast_join.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a join AST node — ast_join","text":"ast_join node","code":""},{"path":"/reference/ast_mutate.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a mutate AST node — ast_mutate","title":"Create a mutate AST node — ast_mutate","text":"Create mutate AST node","code":""},{"path":"/reference/ast_mutate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a mutate AST node — ast_mutate","text":"","code":"ast_mutate(input, expressions)"},{"path":"/reference/ast_mutate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a mutate AST node — ast_mutate","text":"input Input AST node expressions List expression structures","code":""},{"path":"/reference/ast_mutate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a mutate AST node — ast_mutate","text":"ast_mutate node","code":""},{"path":"/reference/ast_node.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an AST node — ast_node","title":"Create an AST node — ast_node","text":"Create AST node","code":""},{"path":"/reference/ast_node.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an AST node — ast_node","text":"","code":"ast_node(type, ..., input = NULL)"},{"path":"/reference/ast_node.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an AST node — ast_node","text":"type Character string identifying node type ... Additional named arguments stored node input input AST node (NULL source nodes)","code":""},{"path":"/reference/ast_node.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an AST node — ast_node","text":"ast_node object","code":""},{"path":"/reference/ast_select.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a select AST node — ast_select","title":"Create a select AST node — ast_select","text":"Create select AST node","code":""},{"path":"/reference/ast_select.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a select AST node — ast_select","text":"","code":"ast_select(input, columns)"},{"path":"/reference/ast_select.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a select AST node — ast_select","text":"input Input AST node columns Character vector column names keep","code":""},{"path":"/reference/ast_select.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a select AST node — ast_select","text":"ast_select node","code":""},{"path":"/reference/ast_source.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a source AST node (leaf node) — ast_source","title":"Create a source AST node (leaf node) — ast_source","text":"Create source AST node (leaf node)","code":""},{"path":"/reference/ast_source.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a source AST node (leaf node) — ast_source","text":"","code":"ast_source(schema, source_ptr = NULL)"},{"path":"/reference/ast_source.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a source AST node (leaf node) — ast_source","text":"schema List names types vectors","code":""},{"path":"/reference/ast_source.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a source AST node (leaf node) — ast_source","text":"ast_source node","code":""},{"path":"/reference/ast_summarise.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a summarise AST node — ast_summarise","title":"Create a summarise AST node — ast_summarise","text":"Create summarise AST node","code":""},{"path":"/reference/ast_summarise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a summarise AST node — ast_summarise","text":"","code":"ast_summarise(input, aggregations, groups)"},{"path":"/reference/ast_summarise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a summarise AST node — ast_summarise","text":"input Input AST node aggregations List aggregation structures groups Character vector group columns (stored explicitly)","code":""},{"path":"/reference/ast_summarise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a summarise AST node — ast_summarise","text":"ast_summarise node","code":""},{"path":"/reference/ast_to_string.html","id":null,"dir":"Reference","previous_headings":"","what":"Format AST as a string for debugging — ast_to_string","title":"Format AST as a string for debugging — ast_to_string","text":"Format AST string debugging","code":""},{"path":"/reference/ast_to_string.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format AST as a string for debugging — ast_to_string","text":"","code":"ast_to_string(node)"},{"path":"/reference/ast_to_string.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format AST as a string for debugging — ast_to_string","text":"node Root AST node","code":""},{"path":"/reference/ast_to_string.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format AST as a string for debugging — ast_to_string","text":"Character string representation","code":""},{"path":"/reference/ast_ungroup.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an ungroup AST node (metadata only) — ast_ungroup","title":"Create an ungroup AST node (metadata only) — ast_ungroup","text":"Create ungroup AST node (metadata )","code":""},{"path":"/reference/ast_ungroup.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an ungroup AST node (metadata only) — ast_ungroup","text":"","code":"ast_ungroup(input)"},{"path":"/reference/ast_ungroup.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an ungroup AST node (metadata only) — ast_ungroup","text":"input Input AST node","code":""},{"path":"/reference/ast_ungroup.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an ungroup AST node (metadata only) — ast_ungroup","text":"ast_ungroup node","code":""},{"path":"/reference/attach_ast_bottom.html","id":null,"dir":"Reference","previous_headings":"","what":"Attach a node at the bottom of an AST — attach_ast_bottom","title":"Attach a node at the bottom of an AST — attach_ast_bottom","text":"Returns new AST bottom input replaced new_input.","code":""},{"path":"/reference/attach_ast_bottom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Attach a node at the bottom of an AST — attach_ast_bottom","text":"","code":"attach_ast_bottom(ast, new_input)"},{"path":"/reference/attach_ast_bottom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Attach a node at the bottom of an AST — attach_ast_bottom","text":"ast AST node new_input Node attach bottom","code":""},{"path":"/reference/attach_ast_bottom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Attach a node at the bottom of an AST — attach_ast_bottom","text":"AST bottom input replaced","code":""},{"path":"/reference/bind_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Bind multiple data frames/tables by column — bind_cols","title":"Bind multiple data frames/tables by column — bind_cols","text":"Combines objects horizontally adding columns. tbl_gpu objects, operations performed GPU. objects, delegates dplyr.","code":""},{"path":"/reference/bind_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bind multiple data frames/tables by column — bind_cols","text":"","code":"bind_cols(   ...,   .name_repair = c(\"unique\", \"universal\", \"check_unique\", \"minimal\") )"},{"path":"/reference/bind_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bind multiple data frames/tables by column — bind_cols","text":"... Objects bind (tbl_gpu, data.frame, list ) .name_repair handle duplicate column names","code":""},{"path":"/reference/bind_cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bind multiple data frames/tables by column — bind_cols","text":"Combined data frame tbl_gpu","code":""},{"path":"/reference/bind_cols_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"GPU bind_cols implementation — bind_cols_gpu","title":"GPU bind_cols implementation — bind_cols_gpu","text":"GPU bind_cols implementation","code":""},{"path":"/reference/bind_cols_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GPU bind_cols implementation — bind_cols_gpu","text":"","code":"bind_cols_gpu(dots, .name_repair = \"unique\")"},{"path":"/reference/bind_cols_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GPU bind_cols implementation — bind_cols_gpu","text":"dots List tables bind .name_repair Name repair method","code":""},{"path":"/reference/bind_cols_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GPU bind_cols implementation — bind_cols_gpu","text":"tbl_gpu","code":""},{"path":"/reference/bind_rows.html","id":null,"dir":"Reference","previous_headings":"","what":"Bind multiple data frames/tables by row — bind_rows","title":"Bind multiple data frames/tables by row — bind_rows","text":"Combines objects vertically stacking rows. tbl_gpu objects, operations performed GPU. objects, delegates dplyr.","code":""},{"path":"/reference/bind_rows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bind multiple data frames/tables by row — bind_rows","text":"","code":"bind_rows(..., .id = NULL)"},{"path":"/reference/bind_rows.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bind multiple data frames/tables by row — bind_rows","text":"... Objects bind (tbl_gpu, data.frame, list ) .id Optional column name identify source tables","code":""},{"path":"/reference/bind_rows.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bind multiple data frames/tables by row — bind_rows","text":"Combined data frame tbl_gpu","code":""},{"path":"/reference/bind_rows_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"GPU bind_rows implementation — bind_rows_gpu","title":"GPU bind_rows implementation — bind_rows_gpu","text":"GPU bind_rows implementation","code":""},{"path":"/reference/bind_rows_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GPU bind_rows implementation — bind_rows_gpu","text":"","code":"bind_rows_gpu(dots, .id = NULL)"},{"path":"/reference/bind_rows_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GPU bind_rows implementation — bind_rows_gpu","text":"dots List tables bind .id Optional column name identify source","code":""},{"path":"/reference/bind_rows_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GPU bind_rows implementation — bind_rows_gpu","text":"tbl_gpu","code":""},{"path":"/reference/cast_column.html","id":null,"dir":"Reference","previous_headings":"","what":"Cast a column to a different type — cast_column","title":"Cast a column to a different type — cast_column","text":"Cast column different type","code":""},{"path":"/reference/cast_column.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cast a column to a different type — cast_column","text":"","code":"cast_column(tbl, col_name, target_type)"},{"path":"/reference/cast_column.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cast a column to a different type — cast_column","text":"tbl tbl_gpu object col_name Name column cast target_type Target type string","code":""},{"path":"/reference/cast_column.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cast a column to a different type — cast_column","text":"tbl_gpu column cast target type","code":""},{"path":"/reference/check_deps.html","id":null,"dir":"Reference","previous_headings":"","what":"Check cuplyr dependencies — check_deps","title":"Check cuplyr dependencies — check_deps","text":"Performs pre-flight check dependencies required install run cuplyr. Reports status NVIDIA driver, CUDA toolkit, libcudf, R version, required R packages.","code":""},{"path":"/reference/check_deps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check cuplyr dependencies — check_deps","text":"","code":"check_deps(format = c(\"text\", \"json\"), verbose = FALSE)"},{"path":"/reference/check_deps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check cuplyr dependencies — check_deps","text":"format Output format: \"text\" human-readable console output, \"json\" machine-readable JSON string. verbose TRUE, print additional details check.","code":""},{"path":"/reference/check_deps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check cuplyr dependencies — check_deps","text":"Invisibly returns list : ok Logical: TRUE required checks pass checks Named list individual check results, ok, value, message fields","code":""},{"path":"/reference/check_deps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check cuplyr dependencies — check_deps","text":"following checks performed: NVIDIA Driver: Verifies nvidia-smi available reports driver version CUDA Toolkit: Checks nvcc, validates CUDA >= 12.2, reports CUDA version libcudf: Looks cudf headers standard paths R Version: Checks R >= 4.3.0 R Packages: Verifies required R packages installed GPU Access: Tests GPU device accessible (cuplyr already installed)","code":""},{"path":[]},{"path":"/reference/check_deps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check cuplyr dependencies — check_deps","text":"","code":"# Human-readable output check_deps() #> cuplyr dependency check #> --------------------------------------------------  #> ✔ NVIDIA Driver: Driver version 590.48.01 #> ✔ CUDA Toolkit: CUDA 13.1 at /opt/cuda #> ✖ libcudf: libcudf headers/libraries not found. Install RAPIDS or set CUDF_HOME/CONDA_PREFIX. #> ✔ R Version: R 4.5.2 #> ✔ R Packages: All 7 required packages installed #> ✔ GPU Access: GPU accessible: NVIDIA GeForce RTX 5070 #> --------------------------------------------------  #> Some checks failed. Fix the issues above.  # Machine-readable JSON check_deps(format = \"json\") #> { #>   \"ok\": false, #>   \"checks\": { #>     \"nvidia_driver\": {\"ok\": true, \"value\": \"590.48.01\", \"message\": \"Driver version 590.48.01\"}, #>     \"cuda_toolkit\": {\"ok\": true, \"value\": \"13.1\", \"message\": \"CUDA 13.1 at /opt/cuda\"}, #>     \"libcudf\": {\"ok\": false, \"value\": null, \"message\": \"libcudf headers/libraries not found. Install RAPIDS or set CUDF_HOME/CONDA_PREFIX.\"}, #>     \"r_version\": {\"ok\": true, \"value\": \"4.5.2\", \"message\": \"R 4.5.2\"}, #>     \"r_packages\": {\"ok\": true, \"value\": \"Rcpp, dplyr, rlang, vctrs, cli, tidyselect, tibble\", \"message\": \"All 7 required packages installed\"}, #>     \"gpu_access\": {\"ok\": true, \"value\": \"NVIDIA GeForce RTX 5070\", \"message\": \"GPU accessible: NVIDIA GeForce RTX 5070\"} #>   } #> }   # Programmatic use result <- check_deps() #> cuplyr dependency check #> --------------------------------------------------  #> ✔ NVIDIA Driver: Driver version 590.48.01 #> ✔ CUDA Toolkit: CUDA 13.1 at /opt/cuda #> ✖ libcudf: libcudf headers/libraries not found. Install RAPIDS or set CUDF_HOME/CONDA_PREFIX. #> ✔ R Version: R 4.5.2 #> ✔ R Packages: All 7 required packages installed #> ✔ GPU Access: GPU accessible: NVIDIA GeForce RTX 5070 #> --------------------------------------------------  #> Some checks failed. Fix the issues above. if (!result$ok) {   message(\"Some checks failed. See result$checks for details.\") } #> Some checks failed. See result$checks for details."},{"path":"/reference/collapse.tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a subquery barrier without executing — collapse.tbl_gpu","title":"Create a subquery barrier without executing — collapse.tbl_gpu","text":"Marks current point pipeline optimization barrier. Operations barrier optimized separately. execute anything collect() compute() called.","code":""},{"path":"/reference/collapse.tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a subquery barrier without executing — collapse.tbl_gpu","text":"","code":"# S3 method for class 'tbl_gpu' collapse(x, ...)"},{"path":"/reference/collapse.tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a subquery barrier without executing — collapse.tbl_gpu","text":"x tbl_gpu object. ... Additional arguments (unused).","code":""},{"path":"/reference/collapse.tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a subquery barrier without executing — collapse.tbl_gpu","text":"tbl_gpu barrier marker lazy_ops.","code":""},{"path":"/reference/collapse.tbl_gpu.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a subquery barrier without executing — collapse.tbl_gpu","text":"Use collapse() want prevent certain optimizations crossing boundary (e.g., prevent filter pushdown past certain point). eager mode, collapse() -op.","code":""},{"path":"/reference/collect.tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Transfer GPU table data back to R — collect.tbl_gpu","title":"Transfer GPU table data back to R — collect.tbl_gpu","text":"Copies data GPU memory back R tibble. typically final step GPU data manipulation pipeline, filtering, mutating, selecting data need.","code":""},{"path":"/reference/collect.tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transfer GPU table data back to R — collect.tbl_gpu","text":"","code":"# S3 method for class 'tbl_gpu' collect(x, ...)"},{"path":"/reference/collect.tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transfer GPU table data back to R — collect.tbl_gpu","text":"x tbl_gpu object created tbl_gpu(). ... Additional arguments (ignored, included compatibility).","code":""},{"path":"/reference/collect.tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transfer GPU table data back to R — collect.tbl_gpu","text":"tibble::tibble containing data GPU table. Column types converted back R types: FLOAT64/FLOAT32 -> numeric (double) INT32/INT64 -> integer numeric STRING -> character BOOL8 -> logical (TRUE/FALSE)","code":""},{"path":[]},{"path":"/reference/collect.tbl_gpu.html","id":"memory-considerations","dir":"Reference","previous_headings":"","what":"Memory considerations","title":"Transfer GPU table data back to R — collect.tbl_gpu","text":"Collecting transfers data GPU CPU memory. large datasets, can slow memory-intensive. Best practice : Filter rows reduce data volume Select needed columns collect results","code":""},{"path":"/reference/collect.tbl_gpu.html","id":"performance","dir":"Reference","previous_headings":"","what":"Performance","title":"Transfer GPU table data back to R — collect.tbl_gpu","text":"Data transfer GPU CPU limited PCIe bandwidth (typically 16-32 GB/s). 1 GB dataset, expect ~50-100ms transfer time.","code":""},{"path":[]},{"path":"/reference/collect.tbl_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transfer GPU table data back to R — collect.tbl_gpu","text":"","code":"if (has_gpu()) {   gpu_mtcars <- tbl_gpu(mtcars)    # Process on GPU, then collect   result <- gpu_mtcars |>     filter(mpg > 20) |>     mutate(kpl = mpg * 0.425) |>     select(mpg, kpl, hp) |>     collect()    # Result is a regular tibble   class(result)   print(result) } #> Error in collect(select(mutate(filter(gpu_mtcars, mpg > 20), kpl = mpg *     0.425), mpg, kpl, hp)): could not find function \"collect\""},{"path":"/reference/compute.tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Force computation of pending GPU operations — compute.tbl_gpu","title":"Force computation of pending GPU operations — compute.tbl_gpu","text":"Executes pending lazy operations stores result new GPU table. Data remains GPU (unlike collect() transfers R).","code":""},{"path":"/reference/compute.tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Force computation of pending GPU operations — compute.tbl_gpu","text":"","code":"# S3 method for class 'tbl_gpu' compute(x, ..., name = NULL)"},{"path":"/reference/compute.tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Force computation of pending GPU operations — compute.tbl_gpu","text":"x tbl_gpu object. ... Additional arguments (unused, compatibility). name Ignored (included dplyr compatibility).","code":""},{"path":"/reference/compute.tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Force computation of pending GPU operations — compute.tbl_gpu","text":"tbl_gpu operations materialized lazy_ops cleared.","code":""},{"path":"/reference/compute.tbl_gpu.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Force computation of pending GPU operations — compute.tbl_gpu","text":"Use compute() want : Force optimization execution lazy pipeline Create checkpoint branching operations Free memory intermediate tables Prepare data non-cuplyr functions need materialized table eager mode, compute() -op since operations execute immediately.","code":""},{"path":[]},{"path":"/reference/compute.tbl_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Force computation of pending GPU operations — compute.tbl_gpu","text":"","code":"if (has_gpu()) {   # Lazy pipeline   lazy_result <- tbl_gpu(mtcars, lazy = TRUE) |>     filter(mpg > 20) |>     mutate(kpl = mpg * 0.425)    # Force execution, keep on GPU   gpu_result <- lazy_result |> compute()    # Now branch into two different analyses   analysis1 <- gpu_result |> filter(cyl == 4) |> collect()   analysis2 <- gpu_result |> filter(cyl == 6) |> collect() } #> Error in mutate(filter(tbl_gpu(mtcars, lazy = TRUE), mpg > 20), kpl = mpg *     0.425): could not find function \"mutate\""},{"path":"/reference/compute_unified_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute unified schema from multiple tables — compute_unified_schema","title":"Compute unified schema from multiple tables — compute_unified_schema","text":"Compute unified schema multiple tables","code":""},{"path":"/reference/compute_unified_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute unified schema from multiple tables — compute_unified_schema","text":"","code":"compute_unified_schema(tables)"},{"path":"/reference/compute_unified_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute unified schema from multiple tables — compute_unified_schema","text":"tables List tbl_gpu objects","code":""},{"path":"/reference/compute_unified_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute unified schema from multiple tables — compute_unified_schema","text":"List names types unified schema","code":""},{"path":"/reference/configure_cloud_library_paths.html","id":null,"dir":"Reference","previous_headings":"","what":"Configure LD_LIBRARY_PATH for cloud environments — configure_cloud_library_paths","title":"Configure LD_LIBRARY_PATH for cloud environments — configure_cloud_library_paths","text":"Sets LD_LIBRARY_PATH real driver path first, takes priority RAPIDS stubs.","code":""},{"path":"/reference/configure_cloud_library_paths.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Configure LD_LIBRARY_PATH for cloud environments — configure_cloud_library_paths","text":"","code":"configure_cloud_library_paths(driver_lib, conda_prefix)"},{"path":"/reference/configure_cloud_library_paths.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Configure LD_LIBRARY_PATH for cloud environments — configure_cloud_library_paths","text":"driver_lib Path directory real libcuda..1. conda_prefix RAPIDS/conda prefix.","code":""},{"path":"/reference/detect_environment.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect the runtime environment — detect_environment","title":"Detect the runtime environment — detect_environment","text":"Identifies whether running Colab, container, cloud GPU instance, locally. Used install_cuplyr() apply environment-specific fixes (e.g. CUDA stub disabling Colab).","code":""},{"path":"/reference/detect_environment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect the runtime environment — detect_environment","text":"","code":"detect_environment(override = Sys.getenv(\"CUPLYR_ENV\"))"},{"path":"/reference/detect_environment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect the runtime environment — detect_environment","text":"override Explicit override, e.g. CUPLYR_ENV env var.","code":""},{"path":"/reference/detect_environment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect the runtime environment — detect_environment","text":"One \"local\", \"colab\", \"container\", \"cloud_gpu\".","code":""},{"path":"/reference/diagnostics.html","id":null,"dir":"Reference","previous_headings":"","what":"System diagnostics for cuplyr — diagnostics","title":"System diagnostics for cuplyr — diagnostics","text":"Collects comprehensive system information debugging installation issues filing bug reports. Includes cuplyr version, R/Rcpp versions, CUDA/cuDF paths, GPU info, environment variables.","code":""},{"path":"/reference/diagnostics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"System diagnostics for cuplyr — diagnostics","text":"","code":"diagnostics(redact = TRUE)"},{"path":"/reference/diagnostics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"System diagnostics for cuplyr — diagnostics","text":"redact TRUE (default), redact potentially sensitive paths (home directory, usernames). Set FALSE local debugging.","code":""},{"path":"/reference/diagnostics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"System diagnostics for cuplyr — diagnostics","text":"Invisibly returns list diagnostic information. Also prints formatted output console.","code":""},{"path":"/reference/diagnostics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"System diagnostics for cuplyr — diagnostics","text":"output includes: Package versions: cuplyr, R, Rcpp, dplyr CUDA info: toolkit version, driver version, CUDA_HOME path libcudf info: CONDA_PREFIX, CUDF_HOME, detected paths GPU info: device name, compute capability, memory Library paths: LD_LIBRARY_PATH, RPATH cuplyr.Environment: OS, distro, key environment variables","code":""},{"path":[]},{"path":"/reference/diagnostics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"System diagnostics for cuplyr — diagnostics","text":"","code":"# Full diagnostics diagnostics() #> cuplyr diagnostics #> ==================================================  #>  #> Package Versions #>   cuplyr:     0.1.1.9000  #>   R:         4.5.2 (x86_64-pc-linux-gnu) #>   Rcpp:       1.1.1  #>   dplyr:      1.2.0  #>  #> System #>   OS:         Linux  #>   Distro:     Arch Linux  #>  #> CUDA #>   CUDA_HOME:  /opt/cuda  #>   CUDA ver:   13.1  #>   Driver:     590.48.01  #>  #> RAPIDS / libcudf #>   CONDA_PREFIX:  ~/miniforge3  #>   CUDF_HOME:     ~/cuplr/rapids-dev/lib/python3.12/site-packages/libcudf  #>  #> GPU #>   Available:  YES #>   Name:       NVIDIA GeForce RTX 5070  #>   Compute:    12.0  #>   Memory:     11.5 GiB total,  10.1 GiB free #>  #> Library Paths #>   LD_LIBRARY_PATH:  /usr/lib64/R/lib:/usr/lib/jvm/java-25-openjdk/lib/server:/usr/lib64/R/lib  #>   cuplyr.so:        ~/R/x86_64-pc-linux-gnu-library/4.5/cuplyr/libs/cuplyr.so  #>   RUNPATH:          0x000000000000001d (RUNPATH)            Library runpath: [~/cuplr/.pixi/envs/default/lib:/usr/lib:/opt/cuda/lib64]  #>  #> ==================================================  #> Paste this output in bug reports: https://github.com/bbtheo/cuplyr/issues  # Redacted for sharing in bug reports diagnostics(redact = TRUE) #> cuplyr diagnostics #> ==================================================  #>  #> Package Versions #>   cuplyr:     0.1.1.9000  #>   R:         4.5.2 (x86_64-pc-linux-gnu) #>   Rcpp:       1.1.1  #>   dplyr:      1.2.0  #>  #> System #>   OS:         Linux  #>   Distro:     Arch Linux  #>  #> CUDA #>   CUDA_HOME:  /opt/cuda  #>   CUDA ver:   13.1  #>   Driver:     590.48.01  #>  #> RAPIDS / libcudf #>   CONDA_PREFIX:  ~/miniforge3  #>   CUDF_HOME:     ~/cuplr/rapids-dev/lib/python3.12/site-packages/libcudf  #>  #> GPU #>   Available:  YES #>   Name:       NVIDIA GeForce RTX 5070  #>   Compute:    12.0  #>   Memory:     11.5 GiB total,  10.1 GiB free #>  #> Library Paths #>   LD_LIBRARY_PATH:  /usr/lib64/R/lib:/usr/lib/jvm/java-25-openjdk/lib/server:/usr/lib64/R/lib  #>   cuplyr.so:        ~/R/x86_64-pc-linux-gnu-library/4.5/cuplyr/libs/cuplyr.so  #>   RUNPATH:          0x000000000000001d (RUNPATH)            Library runpath: [~/cuplr/.pixi/envs/default/lib:/usr/lib:/opt/cuda/lib64]  #>  #> ==================================================  #> Paste this output in bug reports: https://github.com/bbtheo/cuplyr/issues  # Unredacted for local debugging diagnostics(redact = FALSE) #> cuplyr diagnostics #> ==================================================  #>  #> Package Versions #>   cuplyr:     0.1.1.9000  #>   R:         4.5.2 (x86_64-pc-linux-gnu) #>   Rcpp:       1.1.1  #>   dplyr:      1.2.0  #>  #> System #>   OS:         Linux  #>   Distro:     Arch Linux  #>  #> CUDA #>   CUDA_HOME:  /opt/cuda  #>   CUDA ver:   13.1  #>   Driver:     590.48.01  #>  #> RAPIDS / libcudf #>   CONDA_PREFIX:  /home/theo/miniforge3  #>   CUDF_HOME:     /home/theo/cuplr/rapids-dev/lib/python3.12/site-packages/libcudf  #>  #> GPU #>   Available:  YES #>   Name:       NVIDIA GeForce RTX 5070  #>   Compute:    12.0  #>   Memory:     11.5 GiB total,  10.1 GiB free #>  #> Library Paths #>   LD_LIBRARY_PATH:  /usr/lib64/R/lib:/usr/lib/jvm/java-25-openjdk/lib/server:/usr/lib64/R/lib  #>   cuplyr.so:        /home/theo/R/x86_64-pc-linux-gnu-library/4.5/cuplyr/libs/cuplyr.so  #>   RUNPATH:          0x000000000000001d (RUNPATH)            Library runpath: [/home/theo/cuplr/.pixi/envs/default/lib:/usr/lib:/opt/cuda/lib64]  #>  #> ==================================================  #> Paste this output in bug reports: https://github.com/bbtheo/cuplyr/issues"},{"path":"/reference/dim.tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Get dimensions of a GPU table — dim.tbl_gpu","title":"Get dimensions of a GPU table — dim.tbl_gpu","text":"Returns number rows columns GPU table.","code":""},{"path":"/reference/dim.tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get dimensions of a GPU table — dim.tbl_gpu","text":"","code":"# S3 method for class 'tbl_gpu' dim(x)"},{"path":"/reference/dim.tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get dimensions of a GPU table — dim.tbl_gpu","text":"x tbl_gpu object.","code":""},{"path":"/reference/dim.tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get dimensions of a GPU table — dim.tbl_gpu","text":"integer vector length 2: c(nrow, ncol). Returns `c(NA, ncol)","code":""},{"path":"/reference/dim.tbl_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get dimensions of a GPU table — dim.tbl_gpu","text":"","code":"if (has_gpu()) {    } #> NULL"},{"path":"/reference/disable_cuda_stubs.html","id":null,"dir":"Reference","previous_headings":"","what":"Disable CUDA stub libraries in a directory — disable_cuda_stubs","title":"Disable CUDA stub libraries in a directory — disable_cuda_stubs","text":"Disable CUDA stub libraries directory","code":""},{"path":"/reference/disable_cuda_stubs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Disable CUDA stub libraries in a directory — disable_cuda_stubs","text":"","code":"disable_cuda_stubs(lib_dir)"},{"path":"/reference/disable_cuda_stubs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Disable CUDA stub libraries in a directory — disable_cuda_stubs","text":"lib_dir Path search stubs.","code":""},{"path":"/reference/disable_cuda_stubs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Disable CUDA stub libraries in a directory — disable_cuda_stubs","text":"Character vector disabled stub paths (invisible).","code":""},{"path":"/reference/extract_segment_above_barrier.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract segment above a barrier (returns copy) — extract_segment_above_barrier","title":"Extract segment above a barrier (returns copy) — extract_segment_above_barrier","text":"Extract segment barrier (returns copy)","code":""},{"path":"/reference/extract_segment_above_barrier.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract segment above a barrier (returns copy) — extract_segment_above_barrier","text":"","code":"extract_segment_above_barrier(ast, barrier)"},{"path":"/reference/extract_segment_above_barrier.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract segment above a barrier (returns copy) — extract_segment_above_barrier","text":"ast Root node barrier Target barrier node","code":""},{"path":"/reference/extract_segment_above_barrier.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract segment above a barrier (returns copy) — extract_segment_above_barrier","text":"Copy segment NULL input barrier point","code":""},{"path":"/reference/filter.tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Filter rows of a GPU table — filter.tbl_gpu","title":"Filter rows of a GPU table — filter.tbl_gpu","text":"Selects rows GPU table conditions TRUE, similar dplyr::filter(). Filtering performed entirely GPU maximum performance large datasets.","code":""},{"path":"/reference/filter.tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Filter rows of a GPU table — filter.tbl_gpu","text":"","code":"# S3 method for class 'tbl_gpu' filter(.data, ..., .preserve = FALSE)"},{"path":"/reference/filter.tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Filter rows of a GPU table — filter.tbl_gpu","text":".data tbl_gpu object created tbl_gpu(). ... Logical expressions filter . expression comparison form column <op> value column <op> column. Multiple conditions combined (must TRUE). .preserve Ignored. Included compatibility dplyr generic.","code":""},{"path":"/reference/filter.tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Filter rows of a GPU table — filter.tbl_gpu","text":"tbl_gpu object containing rows conditions TRUE. GPU memory filtered result newly allocated.","code":""},{"path":[]},{"path":"/reference/filter.tbl_gpu.html","id":"supported-comparison-operators","dir":"Reference","previous_headings":"","what":"Supported comparison operators","title":"Filter rows of a GPU table — filter.tbl_gpu","text":"== - equal != - equal > - greater >= - greater equal < - less <= - less equal ","code":""},{"path":"/reference/filter.tbl_gpu.html","id":"current-limitations","dir":"Reference","previous_headings":"","what":"Current limitations","title":"Filter rows of a GPU table — filter.tbl_gpu","text":"simple comparisons supported (column op value/column) Compound expressions & | yet supported String comparisons yet implemented numeric scalar values right-hand side","code":""},{"path":"/reference/filter.tbl_gpu.html","id":"performance","dir":"Reference","previous_headings":"","what":"Performance","title":"Filter rows of a GPU table — filter.tbl_gpu","text":"Filtering GPU highly parallel can process billions rows per second. best performance, chain multiple filter conditions rather using compound expressions.","code":""},{"path":[]},{"path":"/reference/filter.tbl_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Filter rows of a GPU table — filter.tbl_gpu","text":"","code":"if (has_gpu()) {   gpu_mtcars <- tbl_gpu(mtcars)    # Filter with single condition   efficient_cars <- gpu_mtcars |>     filter(mpg > 25)    # Multiple conditions (combined with AND)   result <- gpu_mtcars |>     filter(mpg > 20) |>     filter(cyl == 4) |>     collect()    # Compare two columns   gpu_cars <- tbl_gpu(cars)   fast_stops <- gpu_cars |>     filter(dist < speed) |>     collect() } #> Error in storage.mode(x) <- \"double\": 'list' object cannot be coerced to type 'double'"},{"path":"/reference/find_ast_bottom.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the bottom node of an AST (deepest non-NULL input) — find_ast_bottom","title":"Find the bottom node of an AST (deepest non-NULL input) — find_ast_bottom","text":"Find bottom node AST (deepest non-NULL input)","code":""},{"path":"/reference/find_ast_bottom.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the bottom node of an AST (deepest non-NULL input) — find_ast_bottom","text":"","code":"find_ast_bottom(ast)"},{"path":"/reference/find_ast_bottom.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the bottom node of an AST (deepest non-NULL input) — find_ast_bottom","text":"ast AST node","code":""},{"path":"/reference/find_ast_bottom.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the bottom node of an AST (deepest non-NULL input) — find_ast_bottom","text":"Bottom node","code":""},{"path":"/reference/find_calls.html","id":null,"dir":"Reference","previous_headings":"","what":"Recursively find all function calls in an R expression — find_calls","title":"Recursively find all function calls in an R expression — find_calls","text":"Recursively find function calls R expression","code":""},{"path":"/reference/find_calls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Recursively find all function calls in an R expression — find_calls","text":"","code":"find_calls(expr)"},{"path":"/reference/find_calls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Recursively find all function calls in an R expression — find_calls","text":"expr R expression (parse())","code":""},{"path":"/reference/find_calls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Recursively find all function calls in an R expression — find_calls","text":"Character vector function names","code":""},{"path":"/reference/find_next_barrier.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the next barrier node walking down from root — find_next_barrier","title":"Find the next barrier node walking down from root — find_next_barrier","text":"Find next barrier node walking root","code":""},{"path":"/reference/find_next_barrier.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the next barrier node walking down from root — find_next_barrier","text":"","code":"find_next_barrier(ast)"},{"path":"/reference/find_next_barrier.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find the next barrier node walking down from root — find_next_barrier","text":"ast AST node","code":""},{"path":"/reference/find_next_barrier.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the next barrier node walking down from root — find_next_barrier","text":"Barrier node NULL","code":""},{"path":"/reference/find_real_driver_lib.html","id":null,"dir":"Reference","previous_headings":"","what":"Find the real NVIDIA driver library path (not stubs) — find_real_driver_lib","title":"Find the real NVIDIA driver library path (not stubs) — find_real_driver_lib","text":"Find real NVIDIA driver library path (stubs)","code":""},{"path":"/reference/find_real_driver_lib.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find the real NVIDIA driver library path (not stubs) — find_real_driver_lib","text":"","code":"find_real_driver_lib()"},{"path":"/reference/find_real_driver_lib.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find the real NVIDIA driver library path (not stubs) — find_real_driver_lib","text":"Path directory containing real libcuda..1, NULL.","code":""},{"path":"/reference/fuse_filters.html","id":null,"dir":"Reference","previous_headings":"","what":"Mark filter nodes for fused AND-mask lowering — fuse_filters","title":"Mark filter nodes for fused AND-mask lowering — fuse_filters","text":"Mark filter nodes fused -mask lowering","code":""},{"path":"/reference/fuse_filters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mark filter nodes for fused AND-mask lowering — fuse_filters","text":"","code":"fuse_filters(ast)"},{"path":"/reference/fuse_filters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mark filter nodes for fused AND-mask lowering — fuse_filters","text":"ast Root AST node","code":""},{"path":"/reference/fuse_filters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mark filter nodes for fused AND-mask lowering — fuse_filters","text":"AST fused flags set","code":""},{"path":"/reference/fuse_mutates.html","id":null,"dir":"Reference","previous_headings":"","what":"Fuse consecutive mutate nodes when safe — fuse_mutates","title":"Fuse consecutive mutate nodes when safe — fuse_mutates","text":"Fuse consecutive mutate nodes safe","code":""},{"path":"/reference/fuse_mutates.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fuse consecutive mutate nodes when safe — fuse_mutates","text":"","code":"fuse_mutates(ast)"},{"path":"/reference/fuse_mutates.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fuse consecutive mutate nodes when safe — fuse_mutates","text":"ast Root AST node","code":""},{"path":"/reference/fuse_mutates.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fuse consecutive mutate nodes when safe — fuse_mutates","text":"AST fused mutates","code":""},{"path":"/reference/gpu_details.html","id":null,"dir":"Reference","previous_headings":"","what":"Get detailed GPU information — gpu_details","title":"Get detailed GPU information — gpu_details","text":"Retrieves comprehensive information available GPU including device name, compute capability, memory capacity, multiprocessor count.","code":""},{"path":"/reference/gpu_details.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get detailed GPU information — gpu_details","text":"","code":"gpu_details()"},{"path":"/reference/gpu_details.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get detailed GPU information — gpu_details","text":"named list GPU details: available Logical: TRUE GPU available device_count Number CUDA devices device_id ID current device (0-indexed) name GPU model name (e.g., \"NVIDIA GeForce RTX 4090\") compute_capability CUDA compute capability (e.g., \"8.9\") total_memory Total GPU memory bytes free_memory Currently available GPU memory bytes multiprocessors Number streaming multiprocessors (SMs) GPU available, returns list(available = FALSE, device_count = 0).","code":""},{"path":[]},{"path":"/reference/gpu_details.html","id":"compute-capability","dir":"Reference","previous_headings":"","what":"Compute capability","title":"Get detailed GPU information — gpu_details","text":"compute capability indicates GPU architecture supported features: 7.x - Volta/Turing (V100, RTX 20 series) 8.x - Ampere (A100, RTX 30 series) 8.9 - Ada Lovelace (RTX 40 series) 9.x - Hopper (H100) 10.x+ - Blackwell newer","code":""},{"path":"/reference/gpu_details.html","id":"memory","dir":"Reference","previous_headings":"","what":"Memory","title":"Get detailed GPU information — gpu_details","text":"free_memory value reflects memory available time call. applications CUDA contexts may using GPU memory.","code":""},{"path":[]},{"path":"/reference/gpu_details.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get detailed GPU information — gpu_details","text":"","code":"info <- gpu_details() if (info$available) {   cat(\"GPU:\", info$name, \"\\n\")   cat(\"Memory:\", round(info$total_memory / 1e9, 1), \"GB\\n\")   cat(\"Compute:\", info$compute_capability, \"\\n\") } #> GPU: NVIDIA GeForce RTX 5070  #> Memory: 12.3 GB #> Compute: 12.0"},{"path":"/reference/gpu_gc.html","id":null,"dir":"Reference","previous_headings":"","what":"Force GPU memory cleanup — gpu_gc","title":"Force GPU memory cleanup — gpu_gc","text":"Triggers R garbage collection free GPU memory held unreferenced tbl_gpu objects. Use operations GPU memory limited large allocations.","code":""},{"path":"/reference/gpu_gc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Force GPU memory cleanup — gpu_gc","text":"","code":"gpu_gc(verbose = FALSE, aggressive = TRUE)"},{"path":"/reference/gpu_gc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Force GPU memory cleanup — gpu_gc","text":"verbose Logical. TRUE, prints memory freed. Default FALSE. aggressive Logical. TRUE (default), runs multiple GC passes short delays aggressively trigger finalizers. FALSE, runs lighter cleanup pass.","code":""},{"path":"/reference/gpu_gc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Force GPU memory cleanup — gpu_gc","text":"Invisibly returns list memory state cleanup, amount freed bytes gigabytes.","code":""},{"path":"/reference/gpu_gc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Force GPU memory cleanup — gpu_gc","text":"GPU memory automatically freed tbl_gpu objects garbage collected R. However, R's garbage collector know GPU memory pressure may run immediately. function forces garbage collection allows time GPU cleanup. Call function: benchmark iterations removing large GPU objects rm() see --memory errors allocating large new GPU tables","code":""},{"path":[]},{"path":"/reference/gpu_gc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Force GPU memory cleanup — gpu_gc","text":"","code":"if (has_gpu()) {   # Create and discard a GPU table   gpu_df <- tbl_gpu(data.frame(x = runif(1000000)))   rm(gpu_df)    # Force cleanup   gpu_gc(verbose = TRUE) } #> GPU memory freed: 8519680 bytes"},{"path":"/reference/gpu_memory_state.html","id":null,"dir":"Reference","previous_headings":"","what":"Get GPU memory snapshot — gpu_memory_state","title":"Get GPU memory snapshot — gpu_memory_state","text":"Returns current GPU memory state including total, free, used memory. Useful monitoring GPU memory usage operations.","code":""},{"path":"/reference/gpu_memory_state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get GPU memory snapshot — gpu_memory_state","text":"","code":"gpu_memory_state()"},{"path":"/reference/gpu_memory_state.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get GPU memory snapshot — gpu_memory_state","text":"list : available Logical: TRUE GPU available total_bytes Total GPU memory bytes free_bytes Free GPU memory bytes used_bytes Used GPU memory bytes total_gb Total GPU memory gigabytes free_gb Free GPU memory gigabytes used_gb Used GPU memory gigabytes","code":""},{"path":[]},{"path":"/reference/gpu_memory_state.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get GPU memory snapshot — gpu_memory_state","text":"","code":"if (has_gpu()) {   # Check memory before allocation   before <- gpu_memory_state()    # Allocate some GPU data   gpu_df <- tbl_gpu(data.frame(x = runif(1000000)))    # Check memory after allocation   after <- gpu_memory_state()    cat(\"Memory used:\", after$used_gb - before$used_gb, \"GB\\n\") } #> Memory used: 0.008388608 GB"},{"path":"/reference/gpu_memory_usage.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate GPU memory usage of a tbl_gpu object — gpu_memory_usage","title":"Estimate GPU memory usage of a tbl_gpu object — gpu_memory_usage","text":"Calculates estimated GPU memory footprint GPU table based dimensions column types. useful understanding memory requirements working large datasets.","code":""},{"path":"/reference/gpu_memory_usage.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate GPU memory usage of a tbl_gpu object — gpu_memory_usage","text":"","code":"gpu_memory_usage(x)"},{"path":"/reference/gpu_memory_usage.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate GPU memory usage of a tbl_gpu object — gpu_memory_usage","text":"x tbl_gpu object.","code":""},{"path":"/reference/gpu_memory_usage.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate GPU memory usage of a tbl_gpu object — gpu_memory_usage","text":"estimated memory usage bytes (numeric), NA object valid tbl_gpu data GPU.","code":""},{"path":"/reference/gpu_memory_usage.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate GPU memory usage of a tbl_gpu object — gpu_memory_usage","text":"estimate includes: Column data (varies type: 8 bytes FLOAT64, 4 bytes INT32, etc.) Validity bitmasks NA handling (1 bit per row per column) String columns use average estimate 32 bytes per element, may vary significantly based actual string lengths. estimate actual GPU memory usage may higher due : Memory alignment requirements RMM memory pool overhead Temporary allocations","code":""},{"path":[]},{"path":"/reference/gpu_memory_usage.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate GPU memory usage of a tbl_gpu object — gpu_memory_usage","text":"","code":"if (has_gpu()) {   gpu_mtcars <- tbl_gpu(mtcars)   size <- gpu_memory_usage(gpu_mtcars)   cat(\"Estimated GPU memory:\", round(size / 1024, 1), \"KB\\n\") } #> Estimated GPU memory: 2.8 KB"},{"path":"/reference/gpu_object_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Get detailed information about a GPU table object — gpu_object_info","title":"Get detailed information about a GPU table object — gpu_object_info","text":"Returns comprehensive information tbl_gpu object including dimensions, column types, estimated memory usage, verification data resides GPU.","code":""},{"path":"/reference/gpu_object_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get detailed information about a GPU table object — gpu_object_info","text":"","code":"gpu_object_info(x)"},{"path":"/reference/gpu_object_info.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get detailed information about a GPU table object — gpu_object_info","text":"x tbl_gpu object.","code":""},{"path":"/reference/gpu_object_info.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get detailed information about a GPU table object — gpu_object_info","text":"list following components: valid Logical: TRUE object valid tbl_gpu GPU data nrow Number rows ncol Number columns column_names Character vector column names column_types Character vector GPU column types estimated_gpu_bytes Estimated GPU memory usage bytes estimated_gpu_mb Estimated GPU memory usage megabytes r_object_bytes Size R object (small) data_on_gpu Logical: TRUE data verified GPU pointer_valid Logical: TRUE external pointer valid","code":""},{"path":[]},{"path":"/reference/gpu_object_info.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get detailed information about a GPU table object — gpu_object_info","text":"","code":"if (has_gpu()) {   gpu_mtcars <- tbl_gpu(mtcars)   info <- gpu_object_info(gpu_mtcars)   cat(\"Rows:\", info$nrow, \"\\n\")   cat(\"GPU memory:\", round(info$estimated_gpu_mb, 2), \"MB\\n\")   cat(\"Data on GPU:\", info$data_on_gpu, \"\\n\") } #> Rows: 32  #> GPU memory: 0 MB #> Data on GPU: TRUE"},{"path":"/reference/gpu_size_comparison.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare R object size vs GPU data size — gpu_size_comparison","title":"Compare R object size vs GPU data size — gpu_size_comparison","text":"Computes ratio GPU memory usage R object size tbl_gpu object. high ratio confirms data stored GPU, R.","code":""},{"path":"/reference/gpu_size_comparison.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare R object size vs GPU data size — gpu_size_comparison","text":"","code":"gpu_size_comparison(x)"},{"path":"/reference/gpu_size_comparison.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare R object size vs GPU data size — gpu_size_comparison","text":"x tbl_gpu object.","code":""},{"path":"/reference/gpu_size_comparison.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare R object size vs GPU data size — gpu_size_comparison","text":"list : r_bytes Size R object bytes gpu_bytes Estimated GPU memory bytes ratio GPU size divided R size (> 1 data GPU)","code":""},{"path":[]},{"path":"/reference/gpu_size_comparison.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare R object size vs GPU data size — gpu_size_comparison","text":"","code":"if (has_gpu()) {   # Create a larger dataset   df <- data.frame(matrix(runif(10000), ncol = 10))   gpu_df <- tbl_gpu(df)    comparison <- gpu_size_comparison(gpu_df)   cat(\"R object:\", round(comparison$r_bytes / 1024, 1), \"KB\\n\")   cat(\"GPU data:\", round(comparison$gpu_bytes / 1024, 1), \"KB\\n\")   cat(\"Ratio:\", round(comparison$ratio, 1), \"x\\n\") } #> R object: 3.3 KB #> GPU data: 79.3 KB #> Ratio: 24.1 x"},{"path":"/reference/group_by.tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Group a GPU table by one or more columns — group_by.tbl_gpu","title":"Group a GPU table by one or more columns — group_by.tbl_gpu","text":"Marks columns group subsequent operations like dplyr::summarise(). grouping stored metadata perform computation aggregation requested.","code":""},{"path":"/reference/group_by.tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group a GPU table by one or more columns — group_by.tbl_gpu","text":"","code":"# S3 method for class 'tbl_gpu' group_by(.data, ..., .add = FALSE, .drop = TRUE)"},{"path":"/reference/group_by.tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group a GPU table by one or more columns — group_by.tbl_gpu","text":".data tbl_gpu object created tbl_gpu(). ... Column names group . Can unquoted column names tidyselect expressions. .add FALSE (default), override existing groups. TRUE, add existing groups. .drop Ignored. Included compatibility dplyr generic.","code":""},{"path":"/reference/group_by.tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group a GPU table by one or more columns — group_by.tbl_gpu","text":"grouped tbl_gpu object. object data grouping columns recorded use dplyr::summarise().","code":""},{"path":"/reference/group_by.tbl_gpu.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Group a GPU table by one or more columns — group_by.tbl_gpu","text":"Unlike operations like dplyr::filter() dplyr::mutate(), group_by() perform GPU computation. simply records columns used grouping subsequent aggregation operations. actual groupby computation happens call dplyr::summarise() grouped table. lazy approach allows chain multiple operations executing expensive groupby operation.","code":""},{"path":[]},{"path":"/reference/group_by.tbl_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group a GPU table by one or more columns — group_by.tbl_gpu","text":"","code":"if (has_gpu()) {   gpu_mtcars <- tbl_gpu(mtcars)    # Group by a single column   by_cyl <- gpu_mtcars |>     group_by(cyl)    # Group by multiple columns   by_cyl_gear <- gpu_mtcars |>     group_by(cyl, gear)    # Use with summarise for aggregation   result <- gpu_mtcars |>     group_by(cyl) |>     summarise(mean_mpg = mean(mpg)) |>     collect() } #> Error in group_by(gpu_mtcars, cyl): could not find function \"group_by\""},{"path":"/reference/group_vars.tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Get grouping variables from a GPU table — group_vars.tbl_gpu","title":"Get grouping variables from a GPU table — group_vars.tbl_gpu","text":"Returns names columns used grouping.","code":""},{"path":"/reference/group_vars.tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get grouping variables from a GPU table — group_vars.tbl_gpu","text":"","code":"# S3 method for class 'tbl_gpu' group_vars(x)"},{"path":"/reference/group_vars.tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get grouping variables from a GPU table — group_vars.tbl_gpu","text":"x tbl_gpu object.","code":""},{"path":"/reference/group_vars.tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get grouping variables from a GPU table — group_vars.tbl_gpu","text":"character vector grouping column names.","code":""},{"path":"/reference/group_vars.tbl_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get grouping variables from a GPU table — group_vars.tbl_gpu","text":"","code":"if (has_gpu()) {   gpu_mtcars <- tbl_gpu(mtcars)    grouped <- gpu_mtcars |>     group_by(cyl, gear)    group_vars(grouped)  # c(\"cyl\", \"gear\") } #> Error in group_by(gpu_mtcars, cyl, gear): could not find function \"group_by\""},{"path":"/reference/groups.tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Get grouping information from a GPU table — groups.tbl_gpu","title":"Get grouping information from a GPU table — groups.tbl_gpu","text":"Returns list symbols representing grouping columns.","code":""},{"path":"/reference/groups.tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get grouping information from a GPU table — groups.tbl_gpu","text":"","code":"# S3 method for class 'tbl_gpu' groups(x)"},{"path":"/reference/groups.tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get grouping information from a GPU table — groups.tbl_gpu","text":"x tbl_gpu object.","code":""},{"path":"/reference/groups.tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get grouping information from a GPU table — groups.tbl_gpu","text":"list symbols grouping columns.","code":""},{"path":"/reference/groups.tbl_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get grouping information from a GPU table — groups.tbl_gpu","text":"","code":"if (has_gpu()) {   gpu_mtcars <- tbl_gpu(mtcars)    grouped <- gpu_mtcars |>     group_by(cyl)    groups(grouped)  # list(as.symbol(\"cyl\")) } #> Error in group_by(gpu_mtcars, cyl): could not find function \"group_by\""},{"path":"/reference/has_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Check GPU availability — has_gpu","title":"Check GPU availability — has_gpu","text":"Tests whether CUDA-capable GPU available accessible. function useful conditional code run GPU acceleration possible.","code":""},{"path":"/reference/has_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check GPU availability — has_gpu","text":"","code":"has_gpu()"},{"path":"/reference/has_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check GPU availability — has_gpu","text":"TRUE GPU available CUDA properly configured, FALSE otherwise. Returns FALSE (error) CUDA libraries found.","code":""},{"path":"/reference/has_gpu.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check GPU availability — has_gpu","text":"function checks: CUDA driver loaded least one CUDA device present Device accessible (exclusive mode another process)","code":""},{"path":[]},{"path":"/reference/has_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check GPU availability — has_gpu","text":"","code":"if (has_gpu()) {   message(\"GPU acceleration available!\")   gpu_df <- tbl_gpu(mtcars) } else {   message(\"No GPU found, using CPU\") } #> GPU acceleration available!"},{"path":"/reference/has_pending_ops.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a tbl_gpu has pending lazy operations — has_pending_ops","title":"Check if a tbl_gpu has pending lazy operations — has_pending_ops","text":"Check tbl_gpu pending lazy operations","code":""},{"path":"/reference/has_pending_ops.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a tbl_gpu has pending lazy operations — has_pending_ops","text":"","code":"has_pending_ops(.data)"},{"path":"/reference/has_pending_ops.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a tbl_gpu has pending lazy operations — has_pending_ops","text":".data tbl_gpu object.","code":""},{"path":"/reference/has_pending_ops.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if a tbl_gpu has pending lazy operations — has_pending_ops","text":"Logical. TRUE pending operations.","code":""},{"path":"/reference/infer_mutate_output_type.html","id":null,"dir":"Reference","previous_headings":"","what":"Infer output type for a mutate expression — infer_mutate_output_type","title":"Infer output type for a mutate expression — infer_mutate_output_type","text":"Infer output type mutate expression","code":""},{"path":"/reference/infer_mutate_output_type.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infer output type for a mutate expression — infer_mutate_output_type","text":"","code":"infer_mutate_output_type(op, input_types, scalar)"},{"path":"/reference/infer_mutate_output_type.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infer output type for a mutate expression — infer_mutate_output_type","text":"op operation input_types Types input columns scalar Scalar value ","code":""},{"path":"/reference/infer_mutate_output_type.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Infer output type for a mutate expression — infer_mutate_output_type","text":"GPU type string","code":""},{"path":"/reference/infer_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Infer output schema from an AST node — infer_schema","title":"Infer output schema from an AST node — infer_schema","text":"Infer output schema AST node","code":""},{"path":"/reference/infer_schema.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Infer output schema from an AST node — infer_schema","text":"","code":"infer_schema(node)"},{"path":"/reference/infer_schema.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Infer output schema from an AST node — infer_schema","text":"node AST node","code":""},{"path":"/reference/infer_schema.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Infer output schema from an AST node — infer_schema","text":"List names types vectors","code":""},{"path":"/reference/install_cuplyr.html","id":null,"dir":"Reference","previous_headings":"","what":"Install cuplyr from source — install_cuplyr","title":"Install cuplyr from source — install_cuplyr","text":"Installs cuplyr setting build dependencies (needed) running ./configure && R CMD INSTALL .. Supports multiple methods providing CUDA/cuDF dependencies.","code":""},{"path":"/reference/install_cuplyr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Install cuplyr from source — install_cuplyr","text":"","code":"install_cuplyr(   method = c(\"auto\", \"pixi\", \"conda\", \"system\"),   repo = NULL,   ref = \"master\",   conda_prefix = NULL,   configure_args = character(),   dry_run = FALSE,   verbose = FALSE )"},{"path":"/reference/install_cuplyr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Install cuplyr from source — install_cuplyr","text":"method obtain build dependencies: \"auto\" Try methods order: pixi, conda, system \"pixi\" Use pixi manage reproducible environment \"conda\" Use conda/mamba install RAPIDS prefix \"system\" Assume CUDA cuDF already installed system repo GitHub repository URL local path cuplyr source. NULL, assumes current directory cuplyr source tree. ref Git branch tag install. used repo URL. conda_prefix Path conda environment method = \"conda\". Defaults \"/opt/rapids\" temp directory. configure_args Extra arguments passed ./configure. dry_run TRUE, print done without executing. verbose TRUE, print detailed progress.","code":""},{"path":"/reference/install_cuplyr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Install cuplyr from source — install_cuplyr","text":"Invisibly returns TRUE success.","code":""},{"path":[]},{"path":"/reference/install_cuplyr.html","id":"method-details","dir":"Reference","previous_headings":"","what":"Method details","title":"Install cuplyr from source — install_cuplyr","text":"auto (default): Tries methods order preference: pixi PATH pixi.toml exists, use pixi mamba conda PATH, use conda CUDA cuDF already available, use system pixi: Runs pixi run install handles everything. Requires pixi installed. conda: Creates conda environment RAPIDS packages, configures builds cuplyr . Requires mamba conda. system: Assumes CUDA_HOME CONDA_PREFIX/CUDF_HOME already set. Runs ./configure && R CMD INSTALL . directly.","code":""},{"path":"/reference/install_cuplyr.html","id":"pre-flight","dir":"Reference","previous_headings":"","what":"Pre-flight","title":"Install cuplyr from source — install_cuplyr","text":"building, install_cuplyr() runs check_deps() reports missing dependencies. method = \"conda\", missing RAPIDS packages installed automatically.","code":""},{"path":[]},{"path":"/reference/install_cuplyr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Install cuplyr from source — install_cuplyr","text":"","code":"if (FALSE) { # \\dontrun{ # Auto-detect best method install_cuplyr()  # Use conda explicitly install_cuplyr(method = \"conda\")  # System install (CUDA/cuDF already available) install_cuplyr(method = \"system\")  # Preview what would happen install_cuplyr(dry_run = TRUE)  # Install from GitHub install_cuplyr(repo = \"https://github.com/bbtheo/cuplyr.git\") } # }"},{"path":"/reference/is_barrier.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an AST node is an optimization barrier — is_barrier","title":"Check if an AST node is an optimization barrier — is_barrier","text":"Check AST node optimization barrier","code":""},{"path":"/reference/is_barrier.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an AST node is an optimization barrier — is_barrier","text":"","code":"is_barrier(node)"},{"path":"/reference/is_barrier.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an AST node is an optimization barrier — is_barrier","text":"node AST node","code":""},{"path":"/reference/is_barrier.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an AST node is an optimization barrier — is_barrier","text":"TRUE node barrier","code":""},{"path":"/reference/is_lazy.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if a tbl_gpu uses lazy execution — is_lazy","title":"Check if a tbl_gpu uses lazy execution — is_lazy","text":"Check tbl_gpu uses lazy execution","code":""},{"path":"/reference/is_lazy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if a tbl_gpu uses lazy execution — is_lazy","text":"","code":"is_lazy(.data)"},{"path":"/reference/is_lazy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if a tbl_gpu uses lazy execution — is_lazy","text":".data tbl_gpu object.","code":""},{"path":"/reference/is_lazy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if a tbl_gpu uses lazy execution — is_lazy","text":"Logical. TRUE table lazy execution mode.","code":""},{"path":"/reference/is_lazy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if a tbl_gpu uses lazy execution — is_lazy","text":"","code":"if (has_gpu()) {   eager_tbl <- tbl_gpu(mtcars)   is_lazy(eager_tbl)  # FALSE    lazy_tbl <- tbl_gpu(mtcars, lazy = TRUE)   is_lazy(lazy_tbl)   # TRUE } #> [1] TRUE"},{"path":"/reference/is_opaque_expression.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if an expression is opaque (contains unknown functions) — is_opaque_expression","title":"Check if an expression is opaque (contains unknown functions) — is_opaque_expression","text":"Check expression opaque (contains unknown functions)","code":""},{"path":"/reference/is_opaque_expression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if an expression is opaque (contains unknown functions) — is_opaque_expression","text":"","code":"is_opaque_expression(expr_text)"},{"path":"/reference/is_opaque_expression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if an expression is opaque (contains unknown functions) — is_opaque_expression","text":"expr_text Expression text string","code":""},{"path":"/reference/is_opaque_expression.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if an expression is opaque (contains unknown functions) — is_opaque_expression","text":"TRUE expression contains unknown/unsafe functions","code":""},{"path":"/reference/is_tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Test if an object is a GPU table — is_tbl_gpu","title":"Test if an object is a GPU table — is_tbl_gpu","text":"Checks whether object inherits tbl_gpu class.","code":""},{"path":"/reference/is_tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test if an object is a GPU table — is_tbl_gpu","text":"","code":"is_tbl_gpu(x)"},{"path":"/reference/is_tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test if an object is a GPU table — is_tbl_gpu","text":"x R object test.","code":""},{"path":"/reference/is_tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test if an object is a GPU table — is_tbl_gpu","text":"TRUE x tbl_gpu object, FALSE otherwise.","code":""},{"path":"/reference/is_tbl_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test if an object is a GPU table — is_tbl_gpu","text":"","code":"if (has_gpu()) {   gpu_df <- tbl_gpu(mtcars)   is_tbl_gpu(gpu_df)   is_tbl_gpu(mtcars) } #> [1] FALSE"},{"path":"/reference/lower_and_execute.html","id":null,"dir":"Reference","previous_headings":"","what":"Lower and execute an AST against a GPU table — lower_and_execute","title":"Lower and execute an AST against a GPU table — lower_and_execute","text":"Lower execute AST GPU table","code":""},{"path":"/reference/lower_and_execute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lower and execute an AST against a GPU table — lower_and_execute","text":"","code":"lower_and_execute(ast, source_ptr)"},{"path":"/reference/lower_and_execute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lower and execute an AST against a GPU table — lower_and_execute","text":"ast Optimized AST root node source_ptr External pointer source GPU table","code":""},{"path":"/reference/lower_and_execute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lower and execute an AST against a GPU table — lower_and_execute","text":"External pointer result GPU table","code":""},{"path":"/reference/lower_arrange.html","id":null,"dir":"Reference","previous_headings":"","what":"Lower arrange node — lower_arrange","title":"Lower arrange node — lower_arrange","text":"Lower arrange node","code":""},{"path":"/reference/lower_arrange.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lower arrange node — lower_arrange","text":"","code":"lower_arrange(ast, source_ptr)"},{"path":"/reference/lower_filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Lower filter node — lower_filter","title":"Lower filter node — lower_filter","text":"Lower filter node","code":""},{"path":"/reference/lower_filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lower filter node — lower_filter","text":"","code":"lower_filter(ast, source_ptr)"},{"path":"/reference/lower_filter_fused.html","id":null,"dir":"Reference","previous_headings":"","what":"Lower fused filter (AND mask) — lower_filter_fused","title":"Lower fused filter (AND mask) — lower_filter_fused","text":"Lower fused filter (mask)","code":""},{"path":"/reference/lower_filter_fused.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lower fused filter (AND mask) — lower_filter_fused","text":"","code":"lower_filter_fused(ptr, predicates, schema)"},{"path":"/reference/lower_head.html","id":null,"dir":"Reference","previous_headings":"","what":"Lower head node — lower_head","title":"Lower head node — lower_head","text":"Lower head node","code":""},{"path":"/reference/lower_head.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lower head node — lower_head","text":"","code":"lower_head(ast, source_ptr)"},{"path":"/reference/lower_join.html","id":null,"dir":"Reference","previous_headings":"","what":"Lower join node — lower_join","title":"Lower join node — lower_join","text":"Lower join node","code":""},{"path":"/reference/lower_join.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lower join node — lower_join","text":"","code":"lower_join(ast, source_ptr)"},{"path":"/reference/lower_mutate.html","id":null,"dir":"Reference","previous_headings":"","what":"Lower mutate node — lower_mutate","title":"Lower mutate node — lower_mutate","text":"Lower mutate node","code":""},{"path":"/reference/lower_mutate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lower mutate node — lower_mutate","text":"","code":"lower_mutate(ast, source_ptr)"},{"path":"/reference/lower_select.html","id":null,"dir":"Reference","previous_headings":"","what":"Lower select node — lower_select","title":"Lower select node — lower_select","text":"Lower select node","code":""},{"path":"/reference/lower_select.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lower select node — lower_select","text":"","code":"lower_select(ast, source_ptr)"},{"path":"/reference/lower_single_mutate.html","id":null,"dir":"Reference","previous_headings":"","what":"Lower a single mutate expression — lower_single_mutate","title":"Lower a single mutate expression — lower_single_mutate","text":"Lower single mutate expression","code":""},{"path":"/reference/lower_single_mutate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lower a single mutate expression — lower_single_mutate","text":"","code":"lower_single_mutate(ptr, expr, schema)"},{"path":"/reference/lower_summarise.html","id":null,"dir":"Reference","previous_headings":"","what":"Lower summarise node — lower_summarise","title":"Lower summarise node — lower_summarise","text":"Lower summarise node","code":""},{"path":"/reference/lower_summarise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lower summarise node — lower_summarise","text":"","code":"lower_summarise(ast, source_ptr)"},{"path":"/reference/make_aggregation.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an aggregation structure for summarise — make_aggregation","title":"Create an aggregation structure for summarise — make_aggregation","text":"Create aggregation structure summarise","code":""},{"path":"/reference/make_aggregation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an aggregation structure for summarise — make_aggregation","text":"","code":"make_aggregation(output_col, input_col, fn, input_type = NULL)"},{"path":"/reference/make_aggregation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an aggregation structure for summarise — make_aggregation","text":"output_col Output column name input_col Input column name fn Aggregation function name (sum, mean, min, max, n) input_type Input column type","code":""},{"path":"/reference/make_aggregation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an aggregation structure for summarise — make_aggregation","text":"aggregation list structure","code":""},{"path":"/reference/make_mutate_expr.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a mutate expression structure — make_mutate_expr","title":"Create a mutate expression structure — make_mutate_expr","text":"Create mutate expression structure","code":""},{"path":"/reference/make_mutate_expr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a mutate expression structure — make_mutate_expr","text":"","code":"make_mutate_expr(output_col, input_cols, op, scalar = NULL, input_types = NULL)"},{"path":"/reference/make_mutate_expr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a mutate expression structure — make_mutate_expr","text":"output_col Output column name input_cols Character vector input column names op Operation: \"+\", \"-\", \"*\", \"/\", \"^\", \"copy\", function name scalar Numeric scalar NULL input_types Character vector input column types","code":""},{"path":"/reference/make_mutate_expr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a mutate expression structure — make_mutate_expr","text":"expression list structure","code":""},{"path":"/reference/make_predicate.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a filter predicate structure — make_predicate","title":"Create a filter predicate structure — make_predicate","text":"Create filter predicate structure","code":""},{"path":"/reference/make_predicate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a filter predicate structure — make_predicate","text":"","code":"make_predicate(col_name, op, value, is_col_compare = FALSE)"},{"path":"/reference/make_predicate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a filter predicate structure — make_predicate","text":"col_name Column name LHS op Comparison operator value Scalar value column name RHS is_col_compare TRUE RHS column name","code":""},{"path":"/reference/make_predicate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a filter predicate structure — make_predicate","text":"predicate list structure","code":""},{"path":"/reference/mutate.tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Create or modify columns in a GPU table — mutate.tbl_gpu","title":"Create or modify columns in a GPU table — mutate.tbl_gpu","text":"Adds new columns modifies existing columns GPU table using arithmetic expressions, similar dplyr::mutate(). computations performed GPU maximum performance.","code":""},{"path":"/reference/mutate.tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create or modify columns in a GPU table — mutate.tbl_gpu","text":"","code":"# S3 method for class 'tbl_gpu' mutate(.data, ...)"},{"path":"/reference/mutate.tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create or modify columns in a GPU table — mutate.tbl_gpu","text":".data tbl_gpu object created tbl_gpu(). ... Name-value pairs expressions. name gives column name (new existing), value arithmetic expression involving existing columns /scalar values.","code":""},{"path":"/reference/mutate.tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create or modify columns in a GPU table — mutate.tbl_gpu","text":"tbl_gpu object new modified columns. column name already exists, replaced. New columns appended.","code":""},{"path":[]},{"path":"/reference/mutate.tbl_gpu.html","id":"supported-arithmetic-operators","dir":"Reference","previous_headings":"","what":"Supported arithmetic operators","title":"Create or modify columns in a GPU table — mutate.tbl_gpu","text":"+ - addition - - subtraction * - multiplication / - division ^ - exponentiation (power)","code":""},{"path":"/reference/mutate.tbl_gpu.html","id":"column-replacement-behavior","dir":"Reference","previous_headings":"","what":"Column replacement behavior","title":"Create or modify columns in a GPU table — mutate.tbl_gpu","text":"output column name matches existing column, existing column replaced -place (preserving column order). example, mutate(x = x + 1) modify x rather creating duplicate.","code":""},{"path":"/reference/mutate.tbl_gpu.html","id":"current-limitations","dir":"Reference","previous_headings":"","what":"Current limitations","title":"Create or modify columns in a GPU table — mutate.tbl_gpu","text":"binary operations supported (col op value col op col) Complex expressions like (x + y) * z yet supported Functions like sqrt(), log(), abs() yet implemented Result type always FLOAT64 (double precision)","code":""},{"path":"/reference/mutate.tbl_gpu.html","id":"performance","dir":"Reference","previous_headings":"","what":"Performance","title":"Create or modify columns in a GPU table — mutate.tbl_gpu","text":"GPU arithmetic operations highly vectorized can process billions elements per second. Memory bandwidth typically limiting factor, compute.","code":""},{"path":[]},{"path":"/reference/mutate.tbl_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create or modify columns in a GPU table — mutate.tbl_gpu","text":"","code":"if (has_gpu()) {   gpu_mtcars <- tbl_gpu(mtcars)    # Add a new column   result <- gpu_mtcars |>     mutate(kpl = mpg * 0.425) |>     collect()    # Modify an existing column   adjusted <- gpu_mtcars |>     mutate(mpg = mpg + 5) |>     collect()    # Combine two columns   gpu_cars <- tbl_gpu(cars)   result <- gpu_cars |>     mutate(ratio = dist / speed) |>     collect()    # Chain multiple mutations   result <- gpu_mtcars |>     mutate(power_weight = hp / wt) |>     mutate(efficiency = mpg * power_weight) |>     collect() } #> Error in collect(mutate(gpu_mtcars, kpl = mpg * 0.425)): could not find function \"collect\""},{"path":"/reference/names-set-.tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Set column names of a GPU table — names<-.tbl_gpu","title":"Set column names of a GPU table — names<-.tbl_gpu","text":"Set column names GPU table","code":""},{"path":"/reference/names-set-.tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Set column names of a GPU table — names<-.tbl_gpu","text":"","code":"# S3 method for class 'tbl_gpu' names(x) <- value"},{"path":"/reference/names-set-.tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Set column names of a GPU table — names<-.tbl_gpu","text":"x tbl_gpu object. value character vector new column names. Must length number columns, contain NA values, empty strings.","code":""},{"path":"/reference/names-set-.tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Set column names of a GPU table — names<-.tbl_gpu","text":"modified tbl_gpu object.","code":""},{"path":"/reference/names.tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Get column names of a GPU table — names.tbl_gpu","title":"Get column names of a GPU table — names.tbl_gpu","text":"Get column names GPU table","code":""},{"path":"/reference/names.tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get column names of a GPU table — names.tbl_gpu","text":"","code":"# S3 method for class 'tbl_gpu' names(x)"},{"path":"/reference/names.tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get column names of a GPU table — names.tbl_gpu","text":"x tbl_gpu object.","code":""},{"path":"/reference/names.tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get column names of a GPU table — names.tbl_gpu","text":"character vector column names.","code":""},{"path":"/reference/optimize_ast.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimize an AST for GPU execution — optimize_ast","title":"Optimize an AST for GPU execution — optimize_ast","text":"Applies optimization passes correct order.","code":""},{"path":"/reference/optimize_ast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimize an AST for GPU execution — optimize_ast","text":"","code":"optimize_ast(ast)"},{"path":"/reference/optimize_ast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimize an AST for GPU execution — optimize_ast","text":"ast Root AST node","code":""},{"path":"/reference/optimize_ast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimize an AST for GPU execution — optimize_ast","text":"Optimized AST","code":""},{"path":"/reference/optimize_segment.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimize a single segment (no barriers) — optimize_segment","title":"Optimize a single segment (no barriers) — optimize_segment","text":"Optimize single segment (barriers)","code":""},{"path":"/reference/optimize_segment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimize a single segment (no barriers) — optimize_segment","text":"","code":"optimize_segment(ast)"},{"path":"/reference/optimize_segment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimize a single segment (no barriers) — optimize_segment","text":"ast Root segment","code":""},{"path":"/reference/optimize_segment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimize a single segment (no barriers) — optimize_segment","text":"Optimized segment","code":""},{"path":"/reference/optimize_with_barriers.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimize AST respecting barrier nodes — optimize_with_barriers","title":"Optimize AST respecting barrier nodes — optimize_with_barriers","text":"Optimize AST respecting barrier nodes","code":""},{"path":"/reference/optimize_with_barriers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimize AST respecting barrier nodes — optimize_with_barriers","text":"","code":"optimize_with_barriers(ast)"},{"path":"/reference/optimize_with_barriers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimize AST respecting barrier nodes — optimize_with_barriers","text":"ast Root AST node","code":""},{"path":"/reference/optimize_with_barriers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimize AST respecting barrier nodes — optimize_with_barriers","text":"Optimized AST","code":""},{"path":"/reference/patch_makevars_for_cloud.html","id":null,"dir":"Reference","previous_headings":"","what":"Patch Makevars for Colab/cloud: put driver FIRST in RUNPATH — patch_makevars_for_cloud","title":"Patch Makevars for Colab/cloud: put driver FIRST in RUNPATH — patch_makevars_for_cloud","text":"Patch Makevars Colab/cloud: put driver FIRST RUNPATH","code":""},{"path":"/reference/patch_makevars_for_cloud.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Patch Makevars for Colab/cloud: put driver FIRST in RUNPATH — patch_makevars_for_cloud","text":"","code":"patch_makevars_for_cloud(src_dir, driver_lib)"},{"path":"/reference/patch_makevars_for_cloud.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Patch Makevars for Colab/cloud: put driver FIRST in RUNPATH — patch_makevars_for_cloud","text":"src_dir Source directory containing src/Makevars. driver_lib Real driver library path.","code":""},{"path":"/reference/promote_types.html","id":null,"dir":"Reference","previous_headings":"","what":"Promote types for bind_rows compatibility — promote_types","title":"Promote types for bind_rows compatibility — promote_types","text":"Promote types bind_rows compatibility","code":""},{"path":"/reference/promote_types.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Promote types for bind_rows compatibility — promote_types","text":"","code":"promote_types(type1, type2)"},{"path":"/reference/promote_types.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Promote types for bind_rows compatibility — promote_types","text":"type1 First type string type2 Second type string","code":""},{"path":"/reference/promote_types.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Promote types for bind_rows compatibility — promote_types","text":"Promoted type string","code":""},{"path":"/reference/prune_dead_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Prune unused mutate outputs to reduce intermediate width — prune_dead_columns","title":"Prune unused mutate outputs to reduce intermediate width — prune_dead_columns","text":"Walks AST root leaves, tracking columns required downstream. mutate expression whose output required dropped; empty mutate nodes removed entirely.","code":""},{"path":"/reference/prune_dead_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Prune unused mutate outputs to reduce intermediate width — prune_dead_columns","text":"","code":"prune_dead_columns(ast, required_cols = NULL, group_cols = character())"},{"path":"/reference/prune_dead_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Prune unused mutate outputs to reduce intermediate width — prune_dead_columns","text":"ast Root AST node required_cols Columns required parent (NULL = output cols) group_cols Group columns must preserved","code":""},{"path":"/reference/prune_dead_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Prune unused mutate outputs to reduce intermediate width — prune_dead_columns","text":"AST unused mutate outputs pruned","code":""},{"path":"/reference/push_down_filters.html","id":null,"dir":"Reference","previous_headings":"","what":"Push filters below mutates when predicates do not depend on mutate outputs — push_down_filters","title":"Push filters below mutates when predicates do not depend on mutate outputs — push_down_filters","text":"Push filters mutates predicates depend mutate outputs","code":""},{"path":"/reference/push_down_filters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Push filters below mutates when predicates do not depend on mutate outputs — push_down_filters","text":"","code":"push_down_filters(ast)"},{"path":"/reference/push_down_filters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Push filters below mutates when predicates do not depend on mutate outputs — push_down_filters","text":"ast Root AST node","code":""},{"path":"/reference/push_down_filters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Push filters below mutates when predicates do not depend on mutate outputs — push_down_filters","text":"AST filters pushed across mutates safe","code":""},{"path":"/reference/push_down_projections.html","id":null,"dir":"Reference","previous_headings":"","what":"Push down column projections to reduce data width early — push_down_projections","title":"Push down column projections to reduce data width early — push_down_projections","text":"Push column projections reduce data width early","code":""},{"path":"/reference/push_down_projections.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Push down column projections to reduce data width early — push_down_projections","text":"","code":"push_down_projections(ast, required_cols = NULL, group_cols = character())"},{"path":"/reference/push_down_projections.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Push down column projections to reduce data width early — push_down_projections","text":"ast Root AST node required_cols Columns required parent (NULL = output cols) group_cols Group columns must preserved","code":""},{"path":"/reference/push_down_projections.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Push down column projections to reduce data width early — push_down_projections","text":"Optimized AST select nodes inserted","code":""},{"path":"/reference/reorder_filters.html","id":null,"dir":"Reference","previous_headings":"","what":"Reorder filters by estimated cost (cheapest first) — reorder_filters","title":"Reorder filters by estimated cost (cheapest first) — reorder_filters","text":"Reorder filters estimated cost (cheapest first)","code":""},{"path":"/reference/reorder_filters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reorder filters by estimated cost (cheapest first) — reorder_filters","text":"","code":"reorder_filters(ast)"},{"path":"/reference/reorder_filters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reorder filters by estimated cost (cheapest first) — reorder_filters","text":"ast Root AST node","code":""},{"path":"/reference/reorder_filters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reorder filters by estimated cost (cheapest first) — reorder_filters","text":"AST reordered filters","code":""},{"path":"/reference/repair_names.html","id":null,"dir":"Reference","previous_headings":"","what":"Repair duplicate column names — repair_names","title":"Repair duplicate column names — repair_names","text":"Repair duplicate column names","code":""},{"path":"/reference/repair_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Repair duplicate column names — repair_names","text":"","code":"repair_names(names, method = \"unique\")"},{"path":"/reference/repair_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Repair duplicate column names — repair_names","text":"names Character vector column names method Repair method","code":""},{"path":"/reference/repair_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Repair duplicate column names — repair_names","text":"Character vector repaired names","code":""},{"path":"/reference/resolve_exec_mode.html","id":null,"dir":"Reference","previous_headings":"","what":"Resolve execution mode from explicit value, option, or environment variable — resolve_exec_mode","title":"Resolve execution mode from explicit value, option, or environment variable — resolve_exec_mode","text":"Resolve execution mode explicit value, option, environment variable","code":""},{"path":"/reference/resolve_exec_mode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Resolve execution mode from explicit value, option, or environment variable — resolve_exec_mode","text":"","code":"resolve_exec_mode(explicit = NULL)"},{"path":"/reference/resolve_exec_mode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Resolve execution mode from explicit value, option, or environment variable — resolve_exec_mode","text":"explicit Explicit value passed tbl_gpu() NULL","code":""},{"path":"/reference/resolve_exec_mode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Resolve execution mode from explicit value, option, or environment variable — resolve_exec_mode","text":"\"lazy\" \"eager\"","code":""},{"path":"/reference/select.tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Select columns from a GPU table — select.tbl_gpu","title":"Select columns from a GPU table — select.tbl_gpu","text":"Keeps specified columns GPU table, similar dplyr::select(). Supports tidyselect syntax flexible column selection.","code":""},{"path":"/reference/select.tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Select columns from a GPU table — select.tbl_gpu","text":"","code":"# S3 method for class 'tbl_gpu' select(.data, ...)"},{"path":"/reference/select.tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Select columns from a GPU table — select.tbl_gpu","text":".data tbl_gpu object created tbl_gpu(). ... Column names tidyselect expressions specifying columns keep. Supports: Column names: select(x, y, z) Negative selection: select(-x) (yet supported) Range: select(x:z) (yet supported) Helpers: starts_with(), ends_with(), contains(), etc.","code":""},{"path":"/reference/select.tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Select columns from a GPU table — select.tbl_gpu","text":"tbl_gpu object containing selected columns. Column order matches order specified selection.","code":""},{"path":"/reference/select.tbl_gpu.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Select columns from a GPU table — select.tbl_gpu","text":"Column selection creates new GPU table selected columns. original data remains GPU memory garbage collected.","code":""},{"path":"/reference/select.tbl_gpu.html","id":"performance","dir":"Reference","previous_headings":"","what":"Performance","title":"Select columns from a GPU table — select.tbl_gpu","text":"Select operations involve copying column data new table structure. wide tables, selecting fewer columns can significantly reduce memory usage improve performance subsequent operations.","code":""},{"path":[]},{"path":"/reference/select.tbl_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Select columns from a GPU table — select.tbl_gpu","text":"","code":"if (has_gpu()) {   gpu_mtcars <- tbl_gpu(mtcars)    # Select specific columns   result <- gpu_mtcars |>     select(mpg, cyl, hp) |>     collect()    # Select with tidyselect helpers   result <- gpu_mtcars |>     select(starts_with(\"d\")) |>     collect()    # Reorder columns   result <- gpu_mtcars |>     select(hp, mpg, wt) |>     collect() } #> Error in collect(select(gpu_mtcars, mpg, cyl, hp)): could not find function \"collect\""},{"path":"/reference/set_ast_source_ptr.html","id":null,"dir":"Reference","previous_headings":"","what":"Attach a source pointer to the source node in an AST — set_ast_source_ptr","title":"Attach a source pointer to the source node in an AST — set_ast_source_ptr","text":"Attach source pointer source node AST","code":""},{"path":"/reference/set_ast_source_ptr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Attach a source pointer to the source node in an AST — set_ast_source_ptr","text":"","code":"set_ast_source_ptr(node, ptr)"},{"path":"/reference/set_ast_source_ptr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Attach a source pointer to the source node in an AST — set_ast_source_ptr","text":"node Root AST node ptr External pointer GPU table","code":""},{"path":"/reference/set_ast_source_ptr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Attach a source pointer to the source node in an AST — set_ast_source_ptr","text":"AST node source pointer attached","code":""},{"path":"/reference/show_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Display GPU information — show_gpu","title":"Display GPU information — show_gpu","text":"Prints formatted information available GPU console. Useful verifying GPU setup checking available resources.","code":""},{"path":"/reference/show_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Display GPU information — show_gpu","text":"","code":"show_gpu()"},{"path":"/reference/show_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Display GPU information — show_gpu","text":"Invisibly returns GPU info list (gpu_details()).","code":""},{"path":"/reference/show_gpu.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Display GPU information — show_gpu","text":"Output includes: Device name compute capability Total, free, used memory Number streaming multiprocessors","code":""},{"path":[]},{"path":"/reference/show_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Display GPU information — show_gpu","text":"","code":"show_gpu() #> GPU Information #> ----------------------------------------  #> Device:       NVIDIA GeForce RTX 5070  #> Compute:      12.0  #> Memory:       12.3 GB total #>               10.9 GB free #>               1.4 GB used #> SMs:          1"},{"path":"/reference/show_query.html","id":null,"dir":"Reference","previous_headings":"","what":"Show pending operations for a lazy tbl_gpu — show_query","title":"Show pending operations for a lazy tbl_gpu — show_query","text":"Show pending operations lazy tbl_gpu","code":""},{"path":"/reference/show_query.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Show pending operations for a lazy tbl_gpu — show_query","text":"","code":"show_query(.data)"},{"path":"/reference/show_query.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Show pending operations for a lazy tbl_gpu — show_query","text":".data tbl_gpu object.","code":""},{"path":"/reference/show_query.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Show pending operations for a lazy tbl_gpu — show_query","text":"Invisibly returns AST, prints inspection.","code":""},{"path":"/reference/summarise.tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarise groups in a GPU table — summarise.tbl_gpu","title":"Summarise groups in a GPU table — summarise.tbl_gpu","text":"Computes aggregations groups defined dplyr::group_by(). Operations performed entirely GPU maximum performance.","code":""},{"path":"/reference/summarise.tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarise groups in a GPU table — summarise.tbl_gpu","text":"","code":"# S3 method for class 'tbl_gpu' summarise(.data, ..., .groups = \"drop\")  # S3 method for class 'tbl_gpu' summarize(.data, ..., .groups = \"drop\")"},{"path":"/reference/summarise.tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarise groups in a GPU table — summarise.tbl_gpu","text":".data grouped tbl_gpu object created dplyr::group_by(). ... Name-value pairs summary functions. name name variable result. value must single aggregation expression form fun(column). .groups Controls grouping structure result. Currently \"drop\" supported (default).","code":""},{"path":"/reference/summarise.tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarise groups in a GPU table — summarise.tbl_gpu","text":"tbl_gpu object one row per group containing grouping columns computed aggregations.","code":""},{"path":[]},{"path":"/reference/summarise.tbl_gpu.html","id":"supported-aggregation-functions","dir":"Reference","previous_headings":"","what":"Supported aggregation functions","title":"Summarise groups in a GPU table — summarise.tbl_gpu","text":"sum(x) - Sum values mean(x) - Arithmetic mean min(x) - Minimum value max(x) - Maximum value n() - Count rows group sd(x) - Standard deviation var(x) - Variance","code":""},{"path":"/reference/summarise.tbl_gpu.html","id":"na-handling","dir":"Reference","previous_headings":"","what":"NA handling","title":"Summarise groups in a GPU table — summarise.tbl_gpu","text":"default, NA values excluded aggregations. matches default behavior R's base aggregation functions.","code":""},{"path":"/reference/summarise.tbl_gpu.html","id":"ungrouped-summarise","dir":"Reference","previous_headings":"","what":"Ungrouped summarise","title":"Summarise groups in a GPU table — summarise.tbl_gpu","text":".data grouped, summarise compute aggregations rows, returning single-row table.","code":""},{"path":[]},{"path":"/reference/summarise.tbl_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarise groups in a GPU table — summarise.tbl_gpu","text":"","code":"if (has_gpu()) {   gpu_mtcars <- tbl_gpu(mtcars)    # Simple aggregation over all rows   total <- gpu_mtcars |>     summarise(avg_mpg = mean(mpg)) |>     collect()    # Grouped aggregation   by_cyl <- gpu_mtcars |>     group_by(cyl) |>     summarise(       avg_mpg = mean(mpg),       max_hp = max(hp),       count = n()     ) |>     collect()    # Multiple grouping columns   by_cyl_gear <- gpu_mtcars |>     group_by(cyl, gear) |>     summarise(       mean_mpg = mean(mpg),       min_wt = min(wt)     ) |>     collect() } #> Error in collect(summarise(gpu_mtcars, avg_mpg = mean(mpg))): could not find function \"collect\""},{"path":"/reference/tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a GPU-backed data frame — tbl_gpu","title":"Create a GPU-backed data frame — tbl_gpu","text":"Transfers R data frame GPU memory using NVIDIA's libcudf library, enabling high-performance data manipulation operations. resulting tbl_gpu object can used dplyr verbs like filter(), mutate(), select(), collected back R collect().","code":""},{"path":"/reference/tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a GPU-backed data frame — tbl_gpu","text":"","code":"tbl_gpu(data, ..., lazy = NULL)  # S3 method for class 'data.frame' tbl_gpu(data, ..., lazy = NULL)  # S3 method for class 'tbl_gpu' tbl_gpu(data, ..., lazy = NULL)"},{"path":"/reference/tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a GPU-backed data frame — tbl_gpu","text":"data data frame tibble transfer GPU memory. Supported column types include: numeric (double), integer, character, logical. ... Additional arguments passed methods (currently unused). lazy Logical character. Controls execution mode: TRUE \"lazy\" - Operations deferred collect()/compute() FALSE \"eager\" - Operations execute immediately (default) NULL - Use session option environment variable Can also set via options(cuplyr.exec_mode = \"lazy\") environment variable CUPLYR_EXEC_MODE=lazy.","code":""},{"path":"/reference/tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a GPU-backed data frame — tbl_gpu","text":"tbl_gpu object containing: ptr - External pointer GPU table schema - List column names types lazy_ops - AST pending operations (lazy mode ) groups - Grouping variables exec_mode - Execution mode (\"lazy\" \"eager\")","code":""},{"path":"/reference/tbl_gpu.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a GPU-backed data frame — tbl_gpu","text":"data immediately copied GPU memory tbl_gpu() called. GPU memory automatically freed R object garbage collected.","code":""},{"path":"/reference/tbl_gpu.html","id":"execution-modes","dir":"Reference","previous_headings":"","what":"Execution Modes","title":"Create a GPU-backed data frame — tbl_gpu","text":"eager mode (default), dplyr verb executes immediately GPU. simple can lead unnecessary intermediate allocations. lazy mode, operations build AST (Abstract Syntax Tree) optimized executed collect() compute() called. enables optimizations like: Projection pruning (load needed columns) Mutate fusion (combine multiple mutates) Filter reordering (cheapest filters first) Column type mappings R GPU: numeric -> FLOAT64 integer -> INT32 character -> STRING logical -> BOOL8 Date -> TIMESTAMP_DAYS POSIXct -> TIMESTAMP_MICROSECONDS","code":""},{"path":[]},{"path":"/reference/tbl_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a GPU-backed data frame — tbl_gpu","text":"","code":"if (has_gpu()) {   # Transfer mtcars to GPU (eager mode)   gpu_mtcars <- tbl_gpu(mtcars)   print(gpu_mtcars)    # Lazy mode - operations deferred until collect()   result <- tbl_gpu(mtcars, lazy = TRUE) |>     filter(mpg > 20) |>     mutate(kpl = mpg * 0.425) |>     collect()    # Set lazy mode globally   options(cuplyr.exec_mode = \"lazy\") } #> Rows: 32 #> Columns: 11 #> $ mpg  <dbl> 21, 21, 22.8, 21.4, 18.7, 18.1, 14.3, 24.4, 22.8, 19.2 #> $ cyl  <dbl> 6, 6, 4, 6, 8, 6, 8, 4, 4, 6 #> $ disp <dbl> 160, 160, 108, 258, 360, 225, 360, 146.7, 140.8, 167.6 #> $ hp   <dbl> 110, 110, 93, 110, 175, 105, 245, 62, 95, 123 #> $ drat <dbl> 3.9, 3.9, 3.85, 3.08, 3.15, 2.76, 3.21, 3.69, 3.92, 3.92 #> $ wt   <dbl> 2.62, 2.875, 2.32, 3.215, 3.44, 3.46, 3.57, 3.19, 3.15, 3.44 #> $ qsec <dbl> 16.46, 17.02, 18.61, 19.44, 17.02, 20.22, 15.84, 20, 22.9, 18.3 #> $ vs   <dbl> 0, 0, 1, 1, 0, 1, 0, 1, 1, 1 #> $ am   <dbl> 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 #> $ gear <dbl> 4, 4, 4, 3, 3, 3, 3, 4, 4, 4 #> $ carb <dbl> 4, 4, 1, 1, 2, 1, 4, 2, 2, 4 #> Error in collect(mutate(filter(tbl_gpu(mtcars, lazy = TRUE), mpg > 20),     kpl = mpg * 0.425)): could not find function \"collect\""},{"path":"/reference/toposort_expressions.html","id":null,"dir":"Reference","previous_headings":"","what":"Topologically sort expressions to respect dependencies — toposort_expressions","title":"Topologically sort expressions to respect dependencies — toposort_expressions","text":"Topologically sort expressions respect dependencies","code":""},{"path":"/reference/toposort_expressions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Topologically sort expressions to respect dependencies — toposort_expressions","text":"","code":"toposort_expressions(exprs)"},{"path":"/reference/toposort_expressions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Topologically sort expressions to respect dependencies — toposort_expressions","text":"exprs List expression structures","code":""},{"path":"/reference/toposort_expressions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Topologically sort expressions to respect dependencies — toposort_expressions","text":"Sorted list NULL cycle detected","code":""},{"path":"/reference/try_fuse_mutate_pair.html","id":null,"dir":"Reference","previous_headings":"","what":"Try to fuse two consecutive mutate nodes — try_fuse_mutate_pair","title":"Try to fuse two consecutive mutate nodes — try_fuse_mutate_pair","text":"Try fuse two consecutive mutate nodes","code":""},{"path":"/reference/try_fuse_mutate_pair.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Try to fuse two consecutive mutate nodes — try_fuse_mutate_pair","text":"","code":"try_fuse_mutate_pair(lower, upper)"},{"path":"/reference/try_fuse_mutate_pair.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Try to fuse two consecutive mutate nodes — try_fuse_mutate_pair","text":"lower Lower (earlier) mutate node upper Upper (later) mutate node","code":""},{"path":"/reference/try_fuse_mutate_pair.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Try to fuse two consecutive mutate nodes — try_fuse_mutate_pair","text":"Fused mutate node NULL fusion possible","code":""},{"path":"/reference/ungroup.tbl_gpu.html","id":null,"dir":"Reference","previous_headings":"","what":"Remove grouping from a GPU table — ungroup.tbl_gpu","title":"Remove grouping from a GPU table — ungroup.tbl_gpu","text":"Removes grouping information grouped tbl_gpu object.","code":""},{"path":"/reference/ungroup.tbl_gpu.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Remove grouping from a GPU table — ungroup.tbl_gpu","text":"","code":"# S3 method for class 'tbl_gpu' ungroup(x, ...)"},{"path":"/reference/ungroup.tbl_gpu.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Remove grouping from a GPU table — ungroup.tbl_gpu","text":"x tbl_gpu object. ... Ignored. Included compatibility dplyr generic.","code":""},{"path":"/reference/ungroup.tbl_gpu.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Remove grouping from a GPU table — ungroup.tbl_gpu","text":"ungrouped tbl_gpu object.","code":""},{"path":"/reference/ungroup.tbl_gpu.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Remove grouping from a GPU table — ungroup.tbl_gpu","text":"","code":"if (has_gpu()) {   gpu_mtcars <- tbl_gpu(mtcars)    grouped <- gpu_mtcars |>     group_by(cyl)    # Remove grouping   ungrouped <- grouped |>     ungroup()    # Verify groups are removed   length(group_vars(ungrouped))  # 0 } #> Error in group_by(gpu_mtcars, cyl): could not find function \"group_by\""},{"path":"/reference/update_schema_after_mutate.html","id":null,"dir":"Reference","previous_headings":"","what":"Update schema after a mutate expression — update_schema_after_mutate","title":"Update schema after a mutate expression — update_schema_after_mutate","text":"Update schema mutate expression","code":""},{"path":"/reference/update_schema_after_mutate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Update schema after a mutate expression — update_schema_after_mutate","text":"","code":"update_schema_after_mutate(schema, expr)"},{"path":"/reference/verify_gpu_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Verify that data resides on GPU — verify_gpu_data","title":"Verify that data resides on GPU — verify_gpu_data","text":"Performs checks confirm tbl_gpu object data stored GPU, R memory. useful debugging ensuring GPU operations working correctly.","code":""},{"path":"/reference/verify_gpu_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Verify that data resides on GPU — verify_gpu_data","text":"","code":"verify_gpu_data(x)"},{"path":"/reference/verify_gpu_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Verify that data resides on GPU — verify_gpu_data","text":"x tbl_gpu object.","code":""},{"path":"/reference/verify_gpu_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Verify that data resides on GPU — verify_gpu_data","text":"TRUE checks pass data verified GPU, FALSE otherwise.","code":""},{"path":"/reference/verify_gpu_data.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Verify that data resides on GPU — verify_gpu_data","text":"function performs multiple verification steps: Object tbl_gpu class Object valid external pointer GPU operations (dim, types) work pointer R object small (data copy R memory)","code":""},{"path":[]},{"path":"/reference/verify_gpu_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Verify that data resides on GPU — verify_gpu_data","text":"","code":"if (has_gpu()) {   gpu_mtcars <- tbl_gpu(mtcars)    # Should return TRUE   verify_gpu_data(gpu_mtcars)    # Regular data frames return FALSE   verify_gpu_data(mtcars) } #> [1] FALSE"},{"path":"/reference/verify_installation.html","id":null,"dir":"Reference","previous_headings":"","what":"Verify cuplyr installation — verify_installation","title":"Verify cuplyr installation — verify_installation","text":"Performs post-install runtime verification running small GPU round-trip: creates GPU table, performs filter, collects back R. confirms package loads, GPU accessible, basic operations work.","code":""},{"path":"/reference/verify_installation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Verify cuplyr installation — verify_installation","text":"","code":"verify_installation()"},{"path":"/reference/verify_installation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Verify cuplyr installation — verify_installation","text":"Invisibly returns list : ok Logical: TRUE checks pass package_loaded Logical: package loads without error gpu_available Logical: GPU detected accessible gpu_name Character: GPU model name, NA roundtrip_ok Logical: data round-trip succeeded time_seconds Numeric: time round-trip test","code":""},{"path":"/reference/verify_installation.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Verify cuplyr installation — verify_installation","text":"function runs three checks sequence: Package load: library(cuplyr) succeeds GPU detection: gpu_details() shows available GPU Round-trip: tbl_gpu(mtcars) |> filter(mpg > 20) |> collect() returns correct results","code":""},{"path":[]},{"path":"/reference/verify_installation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Verify cuplyr installation — verify_installation","text":"","code":"if (FALSE) { # \\dontrun{ result <- verify_installation() if (result$ok) {   message(\"cuplyr is working!\") } } # }"},{"path":[]},{"path":"/news/index.html","id":"bug-fixes-0-1-1","dir":"Changelog","previous_headings":"","what":"Bug fixes","title":"cuplyr 0.1.1","text":"collect() now correctly restores factor columns original levels. Previously, factor columns returned integer codes instead factors (#3). names<-() now validates replacement value assignment. errors new names wrong length, contain NA values, empty strings, character (#4).","code":""},{"path":"/news/index.html","id":"build-system-0-1-1","dir":"Changelog","previous_headings":"","what":"Build system","title":"cuplyr 0.1.1","text":"Fixed CCCL (CUDA Core Compute Libraries) header detection RAPIDS 25.12+ pixi/conda environments headers located rapids/ subdirectory. configure script now automatically detects <cuda/stream_ref> related headers. Reordered include paths CUDF/RMM headers take precedence system CUDA headers, ensuring consistent CCCL versions.","code":""},{"path":"/news/index.html","id":"documentation-0-1-1","dir":"Changelog","previous_headings":"","what":"Documentation","title":"cuplyr 0.1.1","text":"Added pkgdown documentation site vignettes getting started, complex analysis workflows, query optimization.","code":""},{"path":[]},{"path":"/news/index.html","id":"lazy-evaluation-0-1-0","dir":"Changelog","previous_headings":"","what":"Lazy evaluation","title":"cuplyr 0.1.0","text":"tbl_gpu() gains lazy argument enable deferred execution. Operations build AST (Abstract Syntax Tree) optimized executed collect() compute() called. Set globally options(cuplyr.exec_mode = \"lazy\") CUPLYR_EXEC_MODE=lazy environment variable. Added AST optimizer applies multiple optimization passes execution: Projection pruning: push column selection close data sources Mutate fusion: combine consecutive mutate operations Dead column pruning: remove unused intermediate columns Filter pushdown: move filters earlier pipeline, including across joins Filter reordering: execute cheaper filters first Filter fusion: combine multiple filters single GPU kernel compute() executes pending lazy operations keeps result GPU. collapse() inserts optimization barrier without executing. as_lazy() as_eager() switch execution modes mid-pipeline. is_lazy() has_pending_ops() check current execution state. show_query() displays pending operation tree debugging.","code":""},{"path":"/news/index.html","id":"join-operations-0-1-0","dir":"Changelog","previous_headings":"","what":"Join operations","title":"cuplyr 0.1.0","text":"Added inner_join(), left_join(), right_join(), full_join() combining GPU tables (#2). Joins support automatic key detection (natural join), named vectors different key names, suffix column name conflicts, keep retaining join keys, copy auto-transfer data frames GPU.","code":""},{"path":"/news/index.html","id":"bind-operations-0-1-0","dir":"Changelog","previous_headings":"","what":"Bind operations","title":"cuplyr 0.1.0","text":"Added bind_rows() vertically combining GPU tables automatic schema unification type promotion. Added bind_cols() horizontally combining GPU tables .name_repair duplicate column handling. bind functions automatically materialize lazy tables binding.","code":""},{"path":"/news/index.html","id":"cuplyr-001","dir":"Changelog","previous_headings":"","what":"cuplyr 0.0.1","title":"cuplyr 0.0.1","text":"Initial release cuplyr, GPU-accelerated dplyr backend using NVIDIA’s libcudf library.","code":""},{"path":"/news/index.html","id":"core-functionality-0-0-1","dir":"Changelog","previous_headings":"","what":"Core functionality","title":"cuplyr 0.0.1","text":"tbl_gpu() transfers R data frames GPU memory, returning tbl_gpu object works dplyr verbs. collect() transfers GPU data back R tibble. as_tbl_gpu() coerces data frames GPU tables. is_tbl_gpu() tests object GPU table.","code":""},{"path":"/news/index.html","id":"dplyr-verbs-0-0-1","dir":"Changelog","previous_headings":"","what":"dplyr verbs","title":"cuplyr 0.0.1","text":"filter() supports scalar comparisons (x > 5, x == \"\") column--column comparisons (x > y). Supports boolean vectors filter masks. select() supports column selection name, position, tidyselect helpers. mutate() supports arithmetic operations (+, -, *, /, ^) scalars columns. Supports left-associative chains (e.g., + b + c). arrange() sorts one columns desc() support descending order. Supports .by_group = TRUE grouped tables. group_by() sets grouping metadata subsequent aggregation. ungroup() removes grouping. summarise() computes grouped aggregations support sum(), mean(), min(), max(), n(), sd(), var(). Supports expressions inside aggregation functions (e.g., sum(x > 0)).","code":""},{"path":"/news/index.html","id":"type-support-0-0-1","dir":"Changelog","previous_headings":"","what":"Type support","title":"cuplyr 0.0.1","text":"Supported R types: numeric (FLOAT64), integer (INT32), character (STRING), logical (BOOL8), Date (TIMESTAMP_DAYS), POSIXct (TIMESTAMP_MICROSECONDS). factor columns converted INT32 codes. integer64 columns converted FLOAT64 warning precision loss values exceeding 2^53.","code":""},{"path":"/news/index.html","id":"gpu-memory-utilities-0-0-1","dir":"Changelog","previous_headings":"","what":"GPU memory utilities","title":"cuplyr 0.0.1","text":"gpu_memory_usage() estimates GPU memory footprint tbl_gpu object. gpu_memory_state() returns current GPU memory usage (total, free, used). gpu_gc() forces garbage collection free GPU memory unreferenced tables. gpu_object_info() returns detailed information GPU table. verify_gpu_data() confirms data resides GPU, R memory. gpu_size_comparison() compares R object size vs GPU data size.","code":""},{"path":"/news/index.html","id":"gpu-information-0-0-1","dir":"Changelog","previous_headings":"","what":"GPU information","title":"cuplyr 0.0.1","text":"has_gpu() checks compatible GPU available. gpu_details() returns GPU device information (name, compute capability, memory).","code":""}]
