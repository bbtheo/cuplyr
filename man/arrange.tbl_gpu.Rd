% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/arrange.R
\name{arrange.tbl_gpu}
\alias{arrange.tbl_gpu}
\title{Arrange rows of a GPU table by column values}
\usage{
\method{arrange}{tbl_gpu}(.data, ..., .by_group = FALSE)
}
\arguments{
\item{.data}{A \code{tbl_gpu} object created by \code{\link[=tbl_gpu]{tbl_gpu()}}.}

\item{...}{Column names or expressions to sort by. Use \code{desc(column)} or
\code{-column} for descending order. Multiple columns are sorted in order
of precedence (first column is primary sort key).}

\item{.by_group}{If \code{TRUE} and \code{.data} is grouped, sort within groups by
prepending group columns to the sort specification. Default is \code{FALSE}.}
}
\value{
A \code{tbl_gpu} object with rows reordered. The GPU memory for the
sorted result is newly allocated (approximately 2x table size peak memory).
}
\description{
Orders the rows of a GPU table by the values of specified columns,
similar to \code{dplyr::arrange()}. Sorting is performed entirely on the GPU
using a memory-efficient two-phase algorithm.
}
\details{
\subsection{Sort order}{
\itemize{
\item Default is ascending order
\item Use \code{desc(column)} or \code{-column} for descending order
\item Multiple columns: first column is primary key, second is tiebreaker, etc.
\item Sorting is stable: ties preserve their original relative order
}
}

\subsection{NA handling}{
\itemize{
\item \code{NA} values are placed last for ascending order
\item \code{NA} values are placed first for descending order
}
}

\subsection{Memory usage}{

The arrange operation requires approximately 2x the table size in GPU memory:
\itemize{
\item Original table
\item Sort indices (4 bytes per row)
\item New sorted table
}

For very large tables, consider filtering to reduce size before sorting.
}

\subsection{Supported column types}{

All column types supported by \code{tbl_gpu} can be sorted:
numeric, integer, character, logical, Date, POSIXct.

Note: Character sorting uses binary/UTF-8 ordering, not locale-aware collation.
}
}
\examples{
if (has_gpu()) {
  gpu_mtcars <- tbl_gpu(mtcars)

  # Sort by single column (ascending)
  sorted <- gpu_mtcars |>
    arrange(mpg) |>
    collect()

  # Sort descending
  sorted_desc <- gpu_mtcars |>
    arrange(desc(mpg)) |>
    collect()

  # Multiple columns: primary and secondary sort keys
  sorted_multi <- gpu_mtcars |>
    arrange(cyl, desc(mpg)) |>
    collect()

  # With grouped data
  grouped_sort <- gpu_mtcars |>
    group_by(cyl) |>
    arrange(mpg, .by_group = TRUE) |>
    collect()
}
}
\seealso{
\code{\link{filter.tbl_gpu}} for filtering rows,
\code{\link{select.tbl_gpu}} for selecting columns,
\code{\link{collect.tbl_gpu}} for retrieving results
}
